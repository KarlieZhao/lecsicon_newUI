{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 15, "column": 0}, "map": {"version":3,"sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/src/app/components/resize.tsx"],"sourcesContent":["import { useState, useEffect } from 'react';\nexport const useWindowWidth = (): number => {\n    const [windowWidth, setWindowWidth] = useState(window.innerWidth);\n\n    useEffect(() => {\n        const handleResize = () => {\n            setWindowWidth(window.innerWidth);\n        };\n\n        window.addEventListener('resize', handleResize);\n\n        return () => {\n            window.removeEventListener('resize', handleResize);\n        };\n    }, []);\n\n    return windowWidth;\n};\n\nexport const useWindowHeight = (): number => {\n    const [windowHeight, setWindowHeight] = useState(window.innerHeight);\n\n    useEffect(() => {\n        const handleResize = () => {\n            setWindowHeight(window.innerHeight);\n        };\n\n        window.addEventListener('resize', handleResize);\n\n        return () => {\n            window.removeEventListener('resize', handleResize);\n        };\n    }, []);\n\n    return windowHeight;\n};\n"],"names":[],"mappings":";;;;AAAA;;AACO,MAAM,iBAAiB;IAC1B,MAAM,CAAC,aAAa,eAAe,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE,OAAO,UAAU;IAEhE,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACN,MAAM,eAAe;YACjB,eAAe,OAAO,UAAU;QACpC;QAEA,OAAO,gBAAgB,CAAC,UAAU;QAElC,OAAO;YACH,OAAO,mBAAmB,CAAC,UAAU;QACzC;IACJ,GAAG,EAAE;IAEL,OAAO;AACX;AAEO,MAAM,kBAAkB;IAC3B,MAAM,CAAC,cAAc,gBAAgB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE,OAAO,WAAW;IAEnE,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACN,MAAM,eAAe;YACjB,gBAAgB,OAAO,WAAW;QACtC;QAEA,OAAO,gBAAgB,CAAC,UAAU;QAElC,OAAO;YACH,OAAO,mBAAmB,CAAC,UAAU;QACzC;IACJ,GAAG,EAAE;IAEL,OAAO;AACX"}},
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 53, "column": 0}, "map": {"version":3,"sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/src/app/components/processResponse.tsx"],"sourcesContent":["import { RiTa } from \"rita\";\n\nexport function meetRules(word: string, tokens: string[]): boolean {\n    if (!word || !tokens.length) {\n        return false;\n    }\n    // filter punctuations\n    const filteredTokens = tokens.filter(token => !RiTa.isPunct(token));\n    // Check if the lengths match after filtering\n    if (filteredTokens.length !== word.length) {\n        return false;\n    }\n    // compare each character of the word with the first character of each token\n    return word.split('').every((char, index) =>\n        char === filteredTokens[index][0]\n    );\n}"],"names":[],"mappings":";;;;;;;;;AAEO,SAAS,UAAU,IAAY,EAAE,MAAgB;IACpD,IAAI,CAAC,QAAQ,CAAC,OAAO,MAAM,EAAE;QACzB,OAAO;IACX;IACA,sBAAsB;IACtB,MAAM,iBAAiB,OAAO,MAAM,CAAC,CAAA,QAAS,CAAC,KAAK,OAAO,CAAC;IAC5D,6CAA6C;IAC7C,IAAI,eAAe,MAAM,KAAK,KAAK,MAAM,EAAE;QACvC,OAAO;IACX;IACA,4EAA4E;IAC5E,OAAO,KAAK,KAAK,CAAC,IAAI,KAAK,CAAC,CAAC,MAAM,QAC/B,SAAS,cAAc,CAAC,MAAM,CAAC,EAAE;AAEzC"}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 81, "column": 0}, "map": {"version":3,"sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/src/app/components/generator.tsx"],"sourcesContent":["\nimport { RiTa } from \"rita\";\nimport { useState, ChangeEvent, useEffect } from \"react\";\nimport OpenAI from \"openai\";\nimport { meetRules } from \"./processResponse\";\n\ninterface TokenizedWordData {\n    word: string;\n    sentence: string[];\n}\nconst openai = new OpenAI({\n    organization: \"org-86OHGzDu1zrgxhBRHX4yOeId\",\n    apiKey: import.meta.env.VITE_OPENAI_API_KEY || \"\",\n    dangerouslyAllowBrowser: true\n});\n\n// console.log(import.meta.env.VITE_OPENAI_API_KEY);\n\nexport default function GeneratorSection() {\n    const genPrompt = `I will give you a word. Write a sentence in which the first letter of each word sequentially spells out my word, like an acrostic sentence.\nYour sentence should not contain my word or any of the variations of my word. \nYour response should only contain the sentence you make.\nYour sentence should have a semantic connection with my word.`\n\n    const [inputValue, setInputValue] = useState<string>(\"\"); // State to store the input value\n    const [DisplayedWords, setDisplayedWords] = useState<TokenizedWordData[]>([]);\n    const [userPrompt, setUserPrompt] = useState<string>(\"\");\n    const [sendRequstFlag, setSendRequstFlag] = useState(false);\n\n    const handleInputChange = (event: ChangeEvent<HTMLInputElement>) => {\n        setInputValue(event.target.value);\n    };\n\n    const isWord = (input: string): boolean => {\n        const wordRegex = /^[a-zA-Z]+$/; // Only alphabetic characters\n        return wordRegex.test(input);\n    };\n\n    const handleClick = (word: string) => {\n        // console.log('Clicked word:', word);\n        setInputValue(word);\n        setSendRequstFlag(true);\n    };\n\n    useEffect(() => {\n        if (sendRequstFlag) sendRequest();\n    }, [sendRequstFlag])\n\n    const sendRequest = async () => {\n        setUserPrompt(\"\");\n        if (inputValue.trim() && isWord(inputValue.trim())) {\n            try {\n                const response = await openai.chat.completions.create({\n                    model: \"gpt-4o-mini\",\n                    messages: [\n                        { role: \"developer\", content: genPrompt },\n                        {\n                            role: \"user\",\n                            content: `Make an acrostic sentence for \"${inputValue}\".`,\n                        },\n                    ],\n                    store: false,\n                });\n\n                const data = response.choices?.[0]?.message?.content;\n                if (data) {\n                    const capWord = inputValue.charAt(0).toUpperCase() + inputValue.slice(1);\n                    const words = RiTa.tokenize(data);\n                    const newEntry = { word: capWord, sentence: words };\n                    setDisplayedWords((prevWords) => [...prevWords, newEntry]);\n\n                } else {\n                    setUserPrompt(\"Some error has occurred. Please try again.\");\n                }\n            } catch (error) {\n                console.error(error);\n                setUserPrompt(\"An error occurred while generating the acrostic sentence. Please try again.\");\n            }\n        } else {\n            setUserPrompt('\"' + inputValue + '\"' + \" is not a word. Please type a word with no number, space, or punctuation.\");\n        }\n        setSendRequstFlag(false);\n    }\n\n    const renderTokens = (entry: TokenizedWordData, token: string, index: number) => {\n        const isValid = meetRules(entry.word, entry.sentence);\n\n        return (\n            <span key={index} className={`${isValid ? null : \"text-gray\"}`}>\n                {RiTa.isPunct(token) ? (\n                    <>{token}&nbsp;&nbsp;</>\n                ) : (\n                    <> <a onClick={(e) => {\n                        e.preventDefault();\n                        handleClick(token);\n                    }}>{token}</a>\n                        {index < entry.sentence.length - 1 && <>&nbsp;&nbsp;</>}\n                    </>\n                )}\n            </span>\n        )\n    }\n\n    return (<div className=\"gen-bookmark\">\n        <div>\n            <section className=\"sticky-section\">\n                <div>\n                    <h3>Acrostics Playground <span className=\"small\">Running on GPT o1-mini.</span></h3>\n                    <small> Type or click on a word in the section below to generate. </small>\n                </div>\n                <input name=\"myInput\" className=\"word-input\"\n                    value={inputValue} onChange={handleInputChange} />\n                <button\n                    onClick={() => { setSendRequstFlag(true) }}\n                    disabled={sendRequstFlag}>\n                    {sendRequstFlag ? \"Generating...\" : \"Look Up!\"}</button>\n                <button className=\"clear-button\"\n                    onClick={() => { setDisplayedWords([]) }}>Clear</button>\n                <div className=\"gen-userPrompt\">{userPrompt}</div>\n            </section>\n            <section className=\"generator\">\n                {DisplayedWords && DisplayedWords.map((entry, index) => {\n                    return (\n                        <p key={index}\n                            //check rules, if meet rules: render text blue; else render it gray.\n                            style={{ whiteSpace: 'normal', wordWrap: 'break-word' }}>\n                            <span className=\"text-red\">{entry.word}</span>:<>&nbsp;&nbsp;</>\n                            {entry.sentence?.map((token, index) => renderTokens(entry, token, index))}</p>)\n                })}\n            </section>\n        </div>\n    </div>)\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 346, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 352, "column": 0}, "map": {"version":3,"sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/src/app/components/wordDisplay.tsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\n\ninterface TypewriterEntryProps {\n    word: string;\n    sentence: string;\n    onComplete: () => void;\n}\n\ninterface WordData {\n    word: string;\n    sentence: string;\n}\n\ninterface WordDisplayProps {\n    maxHeight: number;\n}\n\n// Component for individual typewriter entries\nconst TypewriterEntry: React.FC<TypewriterEntryProps> = ({ word, sentence, onComplete }) => {\n    const [displayText, setDisplayText] = useState('');\n    const fullText = `${word}: ${sentence}`;\n    const charIndex = useRef(0);\n    const typewriterSpeed = 70; // Milliseconds per character\n\n    useEffect(() => {\n        const typeNextChar = () => {\n            if (charIndex.current < fullText.length) {\n                setDisplayText(fullText.slice(0, charIndex.current + 1));\n                charIndex.current += 1;\n            } else {\n                onComplete();\n            }\n        };\n\n        const typingInterval = setInterval(typeNextChar, typewriterSpeed);\n\n        return () => clearInterval(typingInterval);\n    }, [fullText, onComplete]);\n\n\n    const renderColoredText = (text: string): React.ReactNode => {\n        // Split text into parts (before and after colon)\n        const parts: string[] = text.split(':');\n        if (parts.length === 1) {\n            // No colon in text, just color first letters of words\n            const words: string[] = text.split(' ');\n            return words.map((word, index) => (\n                <span key={index}>\n                    {index > 0 && ' '}\n                    {word && (\n                        <>\n                            <span className=\"text-red\">{word[0]}</span>\n                            <span>{word.slice(1)}</span>\n                        </>\n                    )}\n                </span>\n            ));\n        } else {\n            // Text contains colon\n            return (\n                <>\n                    <span className=\"text-red\">{parts[0]}</span>:<br />\n                    {parts[1] && (\n                        <>\n                            {/* Process text after colon for first letters */}\n                            {parts[1].split(' ').map((word, index) => (\n                                <span key={index}>\n                                    {index === 0 && ' '}\n                                    {word && (\n                                        <>\n                                            <span className=\"text-red\">{word[0]}</span>\n                                            <span>{word.slice(1)}</span>\n                                            {index < parts[1].split(' ').length - 1 && ' '}\n                                        </>\n                                    )}\n                                </span>\n                            ))}\n                        </>\n                    )}\n                </>\n            );\n        }\n    };\n\n    return <p>{renderColoredText(displayText)}</p>;\n};\n\nconst WordDisplay: React.FC<WordDisplayProps> = ({ maxHeight = 900 }) => {\n    const [displayedWords, setDisplayedWords] = useState<WordData[]>([]);\n    const wordData = useRef<WordData[]>([]);\n    const displayRef = useRef<HTMLDivElement>(null);\n\n    const isTypingRef = useRef(false);\n    const shouldAddNewEntryRef = useRef(false);\n    const cleanupTimeoutRef = useRef<NodeJS.Timeout>();\n    const typewriterTimeoutRef = useRef<NodeJS.Timeout>();\n\n    const newEntryDelay: number = 1200;\n\n    useEffect(() => {\n        return () => {\n            if (cleanupTimeoutRef.current) clearTimeout(cleanupTimeoutRef.current);\n            if (typewriterTimeoutRef.current) clearTimeout(typewriterTimeoutRef.current);\n        };\n    }, []);\n\n    useEffect(() => {\n        const loadJSON = async () => {\n            try {\n                const response = await fetch('words.json');\n                if (response.ok) {\n                    const data: WordData[] = await response.json();\n                    wordData.current = data;\n                    addEntry();\n                } else {\n                    console.error('Failed to load JSON');\n                }\n            } catch (error) {\n                console.error('Error loading JSON:', error);\n            }\n        };\n        loadJSON();\n    }, []);\n\n    // on maxHeight change \n    useEffect(() => {\n        if (displayRef.current && maxHeight) {\n            const currentHeight = displayRef.current.getBoundingClientRect().height;\n            if (currentHeight * 2 + 24 >= maxHeight) {\n                cleanupTimeoutRef.current = setTimeout(() => {\n                    shouldAddNewEntryRef.current = true;\n                    isTypingRef.current = false;\n                    setDisplayedWords([]);\n                }, newEntryDelay);\n            }\n        }\n    }, [maxHeight]);\n\n    //  handle adding new entry after displayedWords cleared\n    useEffect(() => {\n        if (displayedWords.length === 0 && shouldAddNewEntryRef.current) {\n            shouldAddNewEntryRef.current = false;\n            isTypingRef.current = false;\n            addEntry();\n        }\n    }, [displayedWords]);\n\n    const findSentenceByWord = (word: string) => {\n        const found = wordData.current.find((item) => item.word.toLowerCase() === word.toLowerCase());\n        return found ? found.sentence : '';\n    };\n\n    const addEntry = () => {\n        if (!wordData.current.length || isTypingRef.current) return;\n        const currentHeight = displayRef.current?.getBoundingClientRect().height || 0;\n        // console.log(currentHeight * 2 + 24 + \" \" + maxHeight)\n\n        if (currentHeight * 2 + 24 >= maxHeight) {\n            cleanupTimeoutRef.current = setTimeout(() => {\n                shouldAddNewEntryRef.current = true;\n                isTypingRef.current = false;\n                setDisplayedWords([]);\n            }, newEntryDelay);\n            return;\n        }\n\n        isTypingRef.current = true;\n        const randomWord = wordData.current[Math.floor(Math.random() * wordData.current.length)].word;\n        const capWord = randomWord.slice(0, 1).toUpperCase() + randomWord.slice(1);\n        const newWordData = { word: capWord, sentence: findSentenceByWord(randomWord) };\n        setDisplayedWords((prevWords) => [...prevWords, newWordData]);\n    };\n\n    const handleTypewriterComplete = () => {\n        isTypingRef.current = false;\n        typewriterTimeoutRef.current = setTimeout(() => {\n            addEntry();\n        }, newEntryDelay);\n    };\n\n    return (\n        <div>\n            <div id=\"display\" ref={displayRef} style={{ position: 'relative', height: 'fit-content' }}>\n                {displayedWords.map((entry, index) => {\n                    return (\n                        <TypewriterEntry\n                            key={index}\n                            word={entry.word}\n                            sentence={entry.sentence}\n                            onComplete={index === displayedWords.length - 1 ? handleTypewriterComplete : () => { }}\n                        />\n                    )\n                })}\n            </div>\n        </div>\n    );\n};\n\nexport default WordDisplay;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 597, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 603, "column": 0}, "map": {"version":3,"sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/src/app/page.tsx"],"sourcesContent":["\"use client\"\nimport { useRef, useEffect, useState } from 'react'\nimport banner from '@/banner.png'\nimport { useWindowHeight } from './components/resize'\nimport './globals.css'\nimport GeneratorSection from './components/generator'\nimport WordDisplay from './components/wordDisplay'\nimport Image from 'next/image'\nexport default function Home() {\n  const bannerRef = useRef<HTMLImageElement>(null);\n  const collectionRef = useRef<HTMLDivElement>(null);\n  const [bannerHeight, setBannerHeight] = useState(500);\n  const windowHeight = useWindowHeight();\n  const [maxHeight, setMaxHeight] = useState(windowHeight - bannerHeight - 25);\n  const [logoHover, setLogoHover] = useState(false);\n  const [readMore, setReadMore] = useState(\"Read More\");\n\n  useEffect(() => {\n    if (bannerRef.current)\n      setBannerHeight(bannerRef.current.getBoundingClientRect().height);\n    if (collectionRef.current) {\n      const calculatedMaxHeight = windowHeight - bannerHeight - 25;\n      setMaxHeight(calculatedMaxHeight);\n      // console.log(calculatedMaxHeight)\n      collectionRef.current.style.height = `${calculatedMaxHeight}px`\n    }\n  }, [bannerHeight, windowHeight])\n\n  const openReadMore = () => {\n    setReadMore(\"Back\")\n    // Shift the page down\n    window.scrollTo({\n      top: window.innerHeight - 30,\n      behavior: 'smooth',\n    });\n  }\n  const closeReadMore = () => {\n    setReadMore(\"Read More\")\n    // Shift the page down\n    window.scrollTo({\n      top: 0,\n      behavior: 'smooth',\n    });\n  }\n  const openPromptnCode = () => {\n\n  }\n\n  return (\n    <>\n      <div className='background'>\n        <div\n          onMouseOver={() => { setLogoHover(true) }}\n          onMouseOut={() => { setLogoHover(false) }} >\n          <Image src={banner} ref={bannerRef} className={`banner ${logoHover ? \"blur\" : null}`} alt=\"\" />\n          <div className={`acrostic ${logoHover ? \"visible\" : \"invisible\"}`}>\n            <span className='text-highlight'>An acrostic is a poem or other word composition in which the first letter of each new line spells out a word, message or the alphabet.\n            </span> </div>\n        </div>\n\n        <div className='top-box'><span style={{ cursor: \"pointer\" }}>Lecsicon by ¡wénrán zhào!</span></div>\n        <div className='bottom-box'>\n          <div style={{ marginLeft: \"3rem\" }}>Lecsicon is a growing collection of over 24,000 acrostic lines. </div>\n          <div className='read-more'\n            onClick={() => { return readMore === \"Back\" ? closeReadMore() : openReadMore() }}>{readMore}</div>\n        </div>\n        <div className='left-box'></div>\n        <div className='right-box' onClick={() => { openPromptnCode() }}><div>Prompt & Code</div></div>\n      </div >\n\n      <div className='collection' ref={collectionRef}>\n        <h1>From the Collection</h1>\n        <WordDisplay maxHeight={maxHeight} />\n      </div>\n      <GeneratorSection />\n\n      {/* read more  */}\n      <section className='about'>\n        Lecsicon is a collection of over 24,000 acrostics generated by OpenAI&apos;s language model\n        GPT, which serve as a conduit between machine comprehension and human interpretation.\n        <br /><br />Following a specific prompt, GPT\n        made a sentence with a series of words whose first letters\n        sequentially spelled out the given word. At a large scale, this\n        process gives rise to intriguing behavioral patterns in the\n        model. The resulting acrostics also elicit gripping reflections\n        on the nature of this literary device and its role in meaning\n        making.\n\n        <br /> <br />In Lecsicon, the resulting sentences offer a broader context for the original words. Many of the sentences perform similarly to Chomsky’s “colorless green ideas sleep furiously,” but others, such as “Music: Many unexpected sounds indicate creativity” and “Date: Dinner and theater experience,” seem to flesh out how the units of meaning (letter, word, sentence, paragraph) feed into each other and meaning bleeds through the edges–the fractal character of the English language.\n        Large Language model capture words based on their interrelations through computation processes, like a ghost hunting through a latent vector space. In such a space, words only exist in their associations with other words, sentences emerging from context.        <br /> <br />\n        {/* Upon visiting the Lecsicon web page, users can see the word-sentence pairs typed out letter-by-letter by a web-based program. Starting with a random word, the program searches the Lecsicon database for a word that has the smallest Levenshtein distance from the preceding one. Adjusting the temperature slider results in a stronger or weaker spelling similarities between the consecutive words displayed. Typing speed is also influenced by temperature-in the same way as molecular motion is.\n        <br /><br /> */}\n        <p>¡wénrán zhào!<br /><a href=\"https://theunthoughts.com/\" target='_blank'>theunthoughts.com</a></p><p><small>Last Update: Jan 2025</small></p>\n      </section>\n    </>\n  )\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 899, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}