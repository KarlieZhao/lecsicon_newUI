{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"print.js","sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40chevrotain/utils/src/print.ts"],"sourcesContent":["export function PRINT_ERROR(msg: string) {\n  /* istanbul ignore else - can't override global.console in node.js */\n  if (console && console.error) {\n    console.error(`Error: ${msg}`);\n  }\n}\n\nexport function PRINT_WARNING(msg: string) {\n  /* istanbul ignore else - can't override global.console in node.js*/\n  if (console && console.warn) {\n    // TODO: modify docs accordingly\n    console.warn(`Warning: ${msg}`);\n  }\n}\n"],"names":[],"mappings":";;;;AAAM,SAAU,WAAW,CAAC,GAAW;IACrC,mEAAA,EAAqE,CACrE,IAAI,OAAO,IAAI,OAAO,CAAC,KAAK,EAAE;QAC5B,OAAO,CAAC,KAAK,CAAC,CAAA,OAAA,EAAU,GAAG,EAAE,CAAC,CAAC;KAChC;AACH,CAAC;AAEK,SAAU,aAAa,CAAC,GAAW;IACvC,kEAAA,EAAoE,CACpE,IAAI,OAAO,IAAI,OAAO,CAAC,IAAI,EAAE;QAC3B,gCAAgC;QAChC,OAAO,CAAC,IAAI,CAAC,CAAA,SAAA,EAAY,GAAG,EAAE,CAAC,CAAC;KACjC;AACH,CAAC","ignoreList":[0]}},
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"file":"timer.js","sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40chevrotain/utils/src/timer.ts"],"sourcesContent":["export function timer<T>(func: () => T): { time: number; value: T } {\n  const start = new Date().getTime();\n  const val = func();\n  const end = new Date().getTime();\n  const total = end - start;\n  return { time: total, value: val };\n}\n"],"names":[],"mappings":";;;AAAM,SAAU,KAAK,CAAI,IAAa;IACpC,MAAM,KAAK,GAAG,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,CAAC;IACnC,MAAM,GAAG,GAAG,IAAI,EAAE,CAAC;IACnB,MAAM,GAAG,GAAG,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,CAAC;IACjC,MAAM,KAAK,GAAG,GAAG,GAAG,KAAK,CAAC;IAC1B,OAAO;QAAE,IAAI,EAAE,KAAK;QAAE,KAAK,EAAE,GAAG;IAAA,CAAE,CAAC;AACrC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 41, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"file":"to-fast-properties.js","sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40chevrotain/utils/src/to-fast-properties.ts"],"sourcesContent":["// based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\nexport function toFastProperties(toBecomeFast: any) {\n  function FakeConstructor() {}\n\n  // If our object is used as a constructor, it would receive\n  FakeConstructor.prototype = toBecomeFast;\n  const fakeInstance = new (FakeConstructor as any)();\n\n  function fakeAccess() {\n    return typeof fakeInstance.bar;\n  }\n\n  // help V8 understand this is a \"real\" prototype by actually using\n  // the fake instance.\n  fakeAccess();\n  fakeAccess();\n\n  // Always true condition to suppress the Firefox warning of unreachable\n  // code after a return statement.\n  if (1) return toBecomeFast;\n\n  // Eval prevents optimization of this method (even though this is dead code)\n  // - https://esbuild.github.io/content-types/#direct-eval\n  /* istanbul ignore next */\n  // tslint:disable-next-line\n  (0, eval)(toBecomeFast);\n}\n"],"names":[],"mappings":"AAAA,yHAAyH;;;;AACnH,SAAU,gBAAgB,CAAC,YAAiB;IAChD,SAAS,eAAe,IAAI,CAAC;IAE7B,2DAA2D;IAC3D,eAAe,CAAC,SAAS,GAAG,YAAY,CAAC;IACzC,MAAM,YAAY,GAAG,IAAK,eAAuB,EAAE,CAAC;IAEpD,SAAS,UAAU;QACjB,OAAO,OAAO,YAAY,CAAC,GAAG,CAAC;IACjC,CAAC;IAED,kEAAkE;IAClE,qBAAqB;IACrB,UAAU,EAAE,CAAC;IACb,UAAU,EAAE,CAAC;IAEb,uEAAuE;IACvE,iCAAiC;IACjC,IAAI,CAAC,mCAAE,OAAO,YAAY,CAAC;;AAO7B,CAAC","ignoreList":[0]}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 74, "column": 0}, "map": {"version":3,"file":"api.js","sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40chevrotain/utils/src/api.ts"],"sourcesContent":["export { PRINT_WARNING, PRINT_ERROR } from \"./print.js\";\nexport { timer } from \"./timer.js\";\nexport { toFastProperties } from \"./to-fast-properties.js\";\n"],"names":[],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 79, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"file":"model.js","sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40chevrotain/gast/src/model.ts"],"sourcesContent":["import { assign, forEach, isRegExp, isString, map, pickBy } from \"lodash-es\";\nimport type {\n  IGASTVisitor,\n  IProduction,\n  IProductionWithOccurrence,\n  ISerializedGast,\n  TokenType,\n} from \"@chevrotain/types\";\n\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction tokenLabel(tokType: TokenType): string {\n  if (hasTokenLabel(tokType)) {\n    return tokType.LABEL;\n  } else {\n    return tokType.name;\n  }\n}\n\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction hasTokenLabel(\n  obj: TokenType,\n): obj is TokenType & Pick<Required<TokenType>, \"LABEL\"> {\n  return isString(obj.LABEL) && obj.LABEL !== \"\";\n}\n\nexport abstract class AbstractProduction<T extends IProduction = IProduction>\n  implements IProduction\n{\n  public get definition(): T[] {\n    return this._definition;\n  }\n  public set definition(value: T[]) {\n    this._definition = value;\n  }\n\n  constructor(protected _definition: T[]) {}\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this);\n    forEach(this.definition, (prod) => {\n      prod.accept(visitor);\n    });\n  }\n}\n\nexport class NonTerminal\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public nonTerminalName!: string;\n  public label?: string;\n  public referencedRule!: Rule;\n  public idx: number = 1;\n\n  constructor(options: {\n    nonTerminalName: string;\n    label?: string;\n    referencedRule?: Rule;\n    idx?: number;\n  }) {\n    super([]);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n\n  set definition(definition: IProduction[]) {\n    // immutable\n  }\n\n  get definition(): IProduction[] {\n    if (this.referencedRule !== undefined) {\n      return this.referencedRule.definition;\n    }\n    return [];\n  }\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this);\n    // don't visit children of a reference, we will get cyclic infinite loops if we do so\n  }\n}\n\nexport class Rule extends AbstractProduction {\n  public name!: string;\n  public orgText: string = \"\";\n\n  constructor(options: {\n    name: string;\n    definition: IProduction[];\n    orgText?: string;\n  }) {\n    super(options.definition);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n}\n\nexport class Alternative extends AbstractProduction {\n  public ignoreAmbiguities: boolean = false;\n\n  constructor(options: {\n    definition: IProduction[];\n    ignoreAmbiguities?: boolean;\n  }) {\n    super(options.definition);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n}\n\nexport class Option\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1;\n  public maxLookahead?: number;\n\n  constructor(options: {\n    definition: IProduction[];\n    idx?: number;\n    maxLookahead?: number;\n  }) {\n    super(options.definition);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n}\n\nexport class RepetitionMandatory\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1;\n  public maxLookahead?: number;\n\n  constructor(options: {\n    definition: IProduction[];\n    idx?: number;\n    maxLookahead?: number;\n  }) {\n    super(options.definition);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n}\n\nexport class RepetitionMandatoryWithSeparator\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator!: TokenType;\n  public idx: number = 1;\n  public maxLookahead?: number;\n\n  constructor(options: {\n    definition: IProduction[];\n    separator: TokenType;\n    idx?: number;\n  }) {\n    super(options.definition);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n}\n\nexport class Repetition\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator!: TokenType;\n  public idx: number = 1;\n  public maxLookahead?: number;\n\n  constructor(options: {\n    definition: IProduction[];\n    idx?: number;\n    maxLookahead?: number;\n  }) {\n    super(options.definition);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n}\n\nexport class RepetitionWithSeparator\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator!: TokenType;\n  public idx: number = 1;\n  public maxLookahead?: number;\n\n  constructor(options: {\n    definition: IProduction[];\n    separator: TokenType;\n    idx?: number;\n  }) {\n    super(options.definition);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n}\n\nexport class Alternation\n  extends AbstractProduction<Alternative>\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1;\n  public ignoreAmbiguities: boolean = false;\n  public hasPredicates: boolean = false;\n  public maxLookahead?: number;\n\n  public get definition(): Alternative[] {\n    return this._definition;\n  }\n  public set definition(value: Alternative[]) {\n    this._definition = value;\n  }\n\n  constructor(options: {\n    definition: Alternative[];\n    idx?: number;\n    ignoreAmbiguities?: boolean;\n    hasPredicates?: boolean;\n    maxLookahead?: number;\n  }) {\n    super(options.definition);\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n}\n\nexport class Terminal implements IProductionWithOccurrence {\n  public terminalType!: TokenType;\n  public label?: string;\n  public idx: number = 1;\n\n  constructor(options: {\n    terminalType: TokenType;\n    label?: string;\n    idx?: number;\n  }) {\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined),\n    );\n  }\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this);\n  }\n}\n\nexport interface ISerializedBasic extends ISerializedGast {\n  type:\n    | \"Alternative\"\n    | \"Option\"\n    | \"RepetitionMandatory\"\n    | \"Repetition\"\n    | \"Alternation\";\n  idx?: number;\n}\n\nexport interface ISerializedGastRule extends ISerializedGast {\n  type: \"Rule\";\n  name: string;\n  orgText: string;\n}\n\nexport interface ISerializedNonTerminal extends ISerializedGast {\n  type: \"NonTerminal\";\n  name: string;\n  label?: string;\n  idx: number;\n}\n\nexport interface ISerializedTerminal extends ISerializedGast {\n  type: \"Terminal\";\n  name: string;\n  terminalLabel?: string;\n  label?: string;\n  pattern?: string;\n  idx: number;\n}\n\nexport interface ISerializedTerminalWithSeparator extends ISerializedGast {\n  type: \"RepetitionMandatoryWithSeparator\" | \"RepetitionWithSeparator\";\n  idx: number;\n  separator: ISerializedTerminal;\n}\n\nexport type ISerializedGastAny =\n  | ISerializedBasic\n  | ISerializedGastRule\n  | ISerializedNonTerminal\n  | ISerializedTerminal\n  | ISerializedTerminalWithSeparator;\n\nexport function serializeGrammar(topRules: Rule[]): ISerializedGast[] {\n  return map(topRules, serializeProduction);\n}\n\nexport function serializeProduction(node: IProduction): ISerializedGast {\n  function convertDefinition(definition: IProduction[]): ISerializedGast[] {\n    return map(definition, serializeProduction);\n  }\n  /* istanbul ignore else */\n  if (node instanceof NonTerminal) {\n    const serializedNonTerminal: ISerializedNonTerminal = {\n      type: \"NonTerminal\",\n      name: node.nonTerminalName,\n      idx: node.idx,\n    };\n\n    if (isString(node.label)) {\n      serializedNonTerminal.label = node.label;\n    }\n\n    return serializedNonTerminal;\n  } else if (node instanceof Alternative) {\n    return <ISerializedBasic>{\n      type: \"Alternative\",\n      definition: convertDefinition(node.definition),\n    };\n  } else if (node instanceof Option) {\n    return <ISerializedBasic>{\n      type: \"Option\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition),\n    };\n  } else if (node instanceof RepetitionMandatory) {\n    return <ISerializedBasic>{\n      type: \"RepetitionMandatory\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition),\n    };\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\n    return <ISerializedTerminalWithSeparator>{\n      type: \"RepetitionMandatoryWithSeparator\",\n      idx: node.idx,\n      separator: <ISerializedTerminal>(\n        serializeProduction(new Terminal({ terminalType: node.separator }))\n      ),\n      definition: convertDefinition(node.definition),\n    };\n  } else if (node instanceof RepetitionWithSeparator) {\n    return <ISerializedTerminalWithSeparator>{\n      type: \"RepetitionWithSeparator\",\n      idx: node.idx,\n      separator: <ISerializedTerminal>(\n        serializeProduction(new Terminal({ terminalType: node.separator }))\n      ),\n      definition: convertDefinition(node.definition),\n    };\n  } else if (node instanceof Repetition) {\n    return <ISerializedBasic>{\n      type: \"Repetition\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition),\n    };\n  } else if (node instanceof Alternation) {\n    return <ISerializedBasic>{\n      type: \"Alternation\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition),\n    };\n  } else if (node instanceof Terminal) {\n    const serializedTerminal = <ISerializedTerminal>{\n      type: \"Terminal\",\n      name: node.terminalType.name,\n      label: tokenLabel(node.terminalType),\n      idx: node.idx,\n    };\n\n    if (isString(node.label)) {\n      serializedTerminal.terminalLabel = node.label;\n    }\n\n    const pattern = node.terminalType.PATTERN;\n    if (node.terminalType.PATTERN) {\n      serializedTerminal.pattern = isRegExp(pattern)\n        ? (<any>pattern).source\n        : pattern;\n    }\n\n    return serializedTerminal;\n  } else if (node instanceof Rule) {\n    return <ISerializedGastRule>{\n      type: \"Rule\",\n      name: node.name,\n      orgText: node.orgText,\n      definition: convertDefinition(node.definition),\n    };\n    /* c8 ignore next 3 */\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 330, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 336, "column": 0}, "map": {"version":3,"file":"visitor.js","sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40chevrotain/gast/src/visitor.ts"],"sourcesContent":["import {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal,\n} from \"./model.js\";\nimport type { IProduction } from \"@chevrotain/types\";\n\nexport abstract class GAstVisitor {\n  public visit(node: IProduction): any {\n    const nodeAny: any = node;\n    switch (nodeAny.constructor) {\n      case NonTerminal:\n        return this.visitNonTerminal(nodeAny);\n      case Alternative:\n        return this.visitAlternative(nodeAny);\n      case Option:\n        return this.visitOption(nodeAny);\n      case RepetitionMandatory:\n        return this.visitRepetitionMandatory(nodeAny);\n      case RepetitionMandatoryWithSeparator:\n        return this.visitRepetitionMandatoryWithSeparator(nodeAny);\n      case RepetitionWithSeparator:\n        return this.visitRepetitionWithSeparator(nodeAny);\n      case Repetition:\n        return this.visitRepetition(nodeAny);\n      case Alternation:\n        return this.visitAlternation(nodeAny);\n      case Terminal:\n        return this.visitTerminal(nodeAny);\n      case Rule:\n        return this.visitRule(nodeAny);\n      /* c8 ignore next 2 */\n      default:\n        throw Error(\"non exhaustive match\");\n    }\n  }\n\n  /* c8 ignore next */\n  public visitNonTerminal(node: NonTerminal): any {}\n\n  /* c8 ignore next */\n  public visitAlternative(node: Alternative): any {}\n\n  /* c8 ignore next */\n  public visitOption(node: Option): any {}\n\n  /* c8 ignore next */\n  public visitRepetition(node: Repetition): any {}\n\n  /* c8 ignore next */\n  public visitRepetitionMandatory(node: RepetitionMandatory): any {}\n\n  /* c8 ignore next 3 */\n  public visitRepetitionMandatoryWithSeparator(\n    node: RepetitionMandatoryWithSeparator,\n  ): any {}\n\n  /* c8 ignore next */\n  public visitRepetitionWithSeparator(node: RepetitionWithSeparator): any {}\n\n  /* c8 ignore next */\n  public visitAlternation(node: Alternation): any {}\n\n  /* c8 ignore next */\n  public visitTerminal(node: Terminal): any {}\n\n  /* c8 ignore next */\n  public visitRule(node: Rule): any {}\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EACL,WAAW,EACX,WAAW,EACX,WAAW,EACX,MAAM,EACN,UAAU,EACV,mBAAmB,EACnB,gCAAgC,EAChC,uBAAuB,EACvB,IAAI,EACJ,QAAQ,GACT,MAAM,YAAY,CAAC;;AAGd,MAAgB,WAAW;IACxB,KAAK,CAAC,IAAiB,EAAA;QAC5B,MAAM,OAAO,GAAQ,IAAI,CAAC;QAC1B,OAAQ,OAAO,CAAC,WAAW,EAAE;YAC3B,oKAAK,cAAW;gBACd,OAAO,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;YACxC,oKAAK,cAAW;gBACd,OAAO,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;YACxC,oKAAK,SAAM;gBACT,OAAO,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;YACnC,oKAAK,sBAAmB;gBACtB,OAAO,IAAI,CAAC,wBAAwB,CAAC,OAAO,CAAC,CAAC;YAChD,oKAAK,mCAAgC;gBACnC,OAAO,IAAI,CAAC,qCAAqC,CAAC,OAAO,CAAC,CAAC;YAC7D,oKAAK,0BAAuB;gBAC1B,OAAO,IAAI,CAAC,4BAA4B,CAAC,OAAO,CAAC,CAAC;YACpD,oKAAK,aAAU;gBACb,OAAO,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;YACvC,oKAAK,cAAW;gBACd,OAAO,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;YACxC,oKAAK,WAAQ;gBACX,OAAO,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;YACrC,oKAAK,OAAI;gBACP,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;YACjC,oBAAA,EAAsB,CACtB;gBACE,MAAM,KAAK,CAAC,sBAAsB,CAAC,CAAC;SACvC;IACH,CAAC;IAED,kBAAA,EAAoB,CACb,gBAAgB,CAAC,IAAiB,EAAA,CAAQ,CAAC;IAElD,kBAAA,EAAoB,CACb,gBAAgB,CAAC,IAAiB,EAAA,CAAQ,CAAC;IAElD,kBAAA,EAAoB,CACb,WAAW,CAAC,IAAY,EAAA,CAAQ,CAAC;IAExC,kBAAA,EAAoB,CACb,eAAe,CAAC,IAAgB,EAAA,CAAQ,CAAC;IAEhD,kBAAA,EAAoB,CACb,wBAAwB,CAAC,IAAyB,EAAA,CAAQ,CAAC;IAElE,oBAAA,EAAsB,CACf,qCAAqC,CAC1C,IAAsC,EAAA,CAChC,CAAC;IAET,kBAAA,EAAoB,CACb,4BAA4B,CAAC,IAA6B,EAAA,CAAQ,CAAC;IAE1E,kBAAA,EAAoB,CACb,gBAAgB,CAAC,IAAiB,EAAA,CAAQ,CAAC;IAElD,kBAAA,EAAoB,CACb,aAAa,CAAC,IAAc,EAAA,CAAQ,CAAC;IAE5C,kBAAA,EAAoB,CACb,SAAS,CAAC,IAAU,EAAA,CAAQ,CAAC;CACrC","ignoreList":[0]}},
    {"offset": {"line": 380, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 386, "column": 0}, "map": {"version":3,"file":"helpers.js","sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40chevrotain/gast/src/helpers.ts"],"sourcesContent":["import { every, includes, some } from \"lodash-es\";\nimport {\n  AbstractProduction,\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal,\n} from \"./model.js\";\nimport type { IProduction, IProductionWithOccurrence } from \"@chevrotain/types\";\n\nexport function isSequenceProd(\n  prod: IProduction,\n): prod is { definition: IProduction[] } & IProduction {\n  return (\n    prod instanceof Alternative ||\n    prod instanceof Option ||\n    prod instanceof Repetition ||\n    prod instanceof RepetitionMandatory ||\n    prod instanceof RepetitionMandatoryWithSeparator ||\n    prod instanceof RepetitionWithSeparator ||\n    prod instanceof Terminal ||\n    prod instanceof Rule\n  );\n}\n\nexport function isOptionalProd(\n  prod: IProduction,\n  alreadyVisited: NonTerminal[] = [],\n): boolean {\n  const isDirectlyOptional =\n    prod instanceof Option ||\n    prod instanceof Repetition ||\n    prod instanceof RepetitionWithSeparator;\n  if (isDirectlyOptional) {\n    return true;\n  }\n\n  // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n  // empty optional top rule\n  // may be indirectly optional ((A?B?C?) | (D?E?F?))\n  if (prod instanceof Alternation) {\n    // for OR its enough for just one of the alternatives to be optional\n    return some((<Alternation>prod).definition, (subProd: IProduction) => {\n      return isOptionalProd(subProd, alreadyVisited);\n    });\n  } else if (prod instanceof NonTerminal && includes(alreadyVisited, prod)) {\n    // avoiding stack overflow due to infinite recursion\n    return false;\n  } else if (prod instanceof AbstractProduction) {\n    if (prod instanceof NonTerminal) {\n      alreadyVisited.push(prod);\n    }\n    return every(\n      (<AbstractProduction>prod).definition,\n      (subProd: IProduction) => {\n        return isOptionalProd(subProd, alreadyVisited);\n      },\n    );\n  } else {\n    return false;\n  }\n}\n\nexport function isBranchingProd(\n  prod: IProduction,\n): prod is { definition: IProduction[] } & IProduction {\n  return prod instanceof Alternation;\n}\n\nexport function getProductionDslName(prod: IProductionWithOccurrence): string {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    return \"SUBRULE\";\n  } else if (prod instanceof Option) {\n    return \"OPTION\";\n  } else if (prod instanceof Alternation) {\n    return \"OR\";\n  } else if (prod instanceof RepetitionMandatory) {\n    return \"AT_LEAST_ONE\";\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return \"AT_LEAST_ONE_SEP\";\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return \"MANY_SEP\";\n  } else if (prod instanceof Repetition) {\n    return \"MANY\";\n  } else if (prod instanceof Terminal) {\n    return \"CONSUME\";\n    /* c8 ignore next 3 */\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n"],"names":[],"mappings":";;;;;;AACA,OAAO,EACL,kBAAkB,EAClB,WAAW,EACX,WAAW,EACX,WAAW,EACX,MAAM,EACN,UAAU,EACV,mBAAmB,EACnB,gCAAgC,EAChC,uBAAuB,EACvB,IAAI,EACJ,QAAQ,GACT,MAAM,YAAY,CAAC;AAbpB,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM,WAAW,CAAC;;;;;AAgB5C,SAAU,cAAc,CAC5B,IAAiB;IAEjB,OAAO,AACL,IAAI,2KAAY,cAAW,IAC3B,IAAI,2KAAY,SAAM,IACtB,IAAI,2KAAY,aAAU,IAC1B,IAAI,0KAAY,uBAAmB,IACnC,IAAI,2KAAY,mCAAgC,IAChD,IAAI,2KAAY,0BAAuB,IACvC,IAAI,2KAAY,WAAQ,IACxB,IAAI,2KAAY,OAAI,CACrB,CAAC;AACJ,CAAC;AAEK,SAAU,cAAc,CAC5B,IAAiB,EACjB,iBAAgC,EAAE;IAElC,MAAM,kBAAkB,GACtB,IAAI,2KAAY,SAAM,IACtB,IAAI,0KAAY,cAAU,IAC1B,IAAI,2KAAY,0BAAuB,CAAC;IAC1C,IAAI,kBAAkB,EAAE;QACtB,OAAO,IAAI,CAAC;KACb;IAED,mHAAmH;IACnH,0BAA0B;IAC1B,mDAAmD;IACnD,IAAI,IAAI,YAAY,6KAAW,EAAE;QAC/B,oEAAoE;QACpE,sLAAO,OAAA,AAAI,EAAe,IAAK,CAAC,UAAU,EAAE,CAAC,OAAoB,EAAE,EAAE;YACnE,OAAO,cAAc,CAAC,OAAO,EAAE,cAAc,CAAC,CAAC;QACjD,CAAC,CAAC,CAAC;KACJ,MAAM,IAAI,IAAI,2KAAY,cAAW,KAAI,iMAAA,AAAQ,EAAC,cAAc,EAAE,IAAI,CAAC,EAAE;QACxE,oDAAoD;QACpD,OAAO,KAAK,CAAC;KACd,MAAM,IAAI,IAAI,YAAY,oLAAkB,EAAE;QAC7C,IAAI,IAAI,2KAAY,cAAW,EAAE;YAC/B,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC3B;QACD,OAAO,yLAAA,AAAK,EACW,IAAK,CAAC,UAAU,EACrC,CAAC,OAAoB,EAAE,EAAE;YACvB,OAAO,cAAc,CAAC,OAAO,EAAE,cAAc,CAAC,CAAC;QACjD,CAAC,CACF,CAAC;KACH,MAAM;QACL,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAEK,SAAU,eAAe,CAC7B,IAAiB;IAEjB,OAAO,IAAI,2KAAY,cAAW,CAAC;AACrC,CAAC;AAEK,SAAU,oBAAoB,CAAC,IAA+B;IAClE,wBAAA,EAA0B,CAC1B,IAAI,IAAI,2KAAY,cAAW,EAAE;QAC/B,OAAO,SAAS,CAAC;KAClB,MAAM,IAAI,IAAI,2KAAY,SAAM,EAAE;QACjC,OAAO,QAAQ,CAAC;KACjB,MAAM,IAAI,IAAI,2KAAY,cAAW,EAAE;QACtC,OAAO,IAAI,CAAC;KACb,MAAM,IAAI,IAAI,YAAY,qLAAmB,EAAE;QAC9C,OAAO,cAAc,CAAC;KACvB,MAAM,IAAI,IAAI,2KAAY,mCAAgC,EAAE;QAC3D,OAAO,kBAAkB,CAAC;KAC3B,MAAM,IAAI,IAAI,2KAAY,0BAAuB,EAAE;QAClD,OAAO,UAAU,CAAC;KACnB,MAAM,IAAI,IAAI,2KAAY,aAAU,EAAE;QACrC,OAAO,MAAM,CAAC;KACf,MAAM,IAAI,IAAI,2KAAY,WAAQ,EAAE;QACnC,OAAO,SAAS,CAAC;IACjB,oBAAA,EAAsB,EACvB,MAAM;QACL,MAAM,KAAK,CAAC,sBAAsB,CAAC,CAAC;KACrC;AACH,CAAC","ignoreList":[0]}},
    {"offset": {"line": 452, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 458, "column": 0}, "map": {"version":3,"file":"api.js","sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40chevrotain/gast/src/api.ts"],"sourcesContent":["export {\n  Rule,\n  Terminal,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Alternation,\n  Alternative,\n  serializeGrammar,\n  serializeProduction,\n} from \"./model.js\";\n\nexport { GAstVisitor } from \"./visitor.js\";\n\nexport {\n  getProductionDslName,\n  isOptionalProd,\n  isBranchingProd,\n  isSequenceProd,\n} from \"./helpers.js\";\n"],"names":[],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 463, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 480, "column": 0}, "map": {"version":3,"file":"utils.js","sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40chevrotain/regexp-to-ast/src/utils.ts"],"sourcesContent":["import type { Character, IRegExpAST, RegExpFlags } from \"../types\";\n\nexport function cc(char: string): number {\n  return char.charCodeAt(0);\n}\n\nexport function insertToSet<T>(item: T | T[], set: T[]) {\n  if (Array.isArray(item)) {\n    item.forEach(function (subItem) {\n      set.push(subItem);\n    });\n  } else {\n    set.push(item);\n  }\n}\n\nexport function addFlag(\n  flagObj: RegExpFlags,\n  flagKey: keyof Omit<RegExpFlags, keyof IRegExpAST>,\n) {\n  if (flagObj[flagKey] === true) {\n    throw \"duplicate flag \" + flagKey;\n  }\n\n  const x: boolean = flagObj[flagKey];\n  flagObj[flagKey] = true;\n}\n\nexport function ASSERT_EXISTS<T = Object>(obj: any): obj is T {\n  // istanbul ignore next\n  if (obj === undefined) {\n    throw Error(\"Internal Error - Should never get here!\");\n  }\n  return true;\n}\n\n// istanbul ignore next\nexport function ASSERT_NEVER_REACH_HERE(): any {\n  throw Error(\"Internal Error - Should never get here!\");\n}\n\nexport function isCharacter(obj: { type: string }): obj is Character {\n  return obj[\"type\"] === \"Character\";\n}\n"],"names":[],"mappings":";;;;;;;;AAEM,SAAU,EAAE,CAAC,IAAY;IAC7B,OAAO,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC;AAEK,SAAU,WAAW,CAAI,IAAa,EAAE,GAAQ;IACpD,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;QACvB,IAAI,CAAC,OAAO,CAAC,SAAU,OAAO;YAC5B,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACpB,CAAC,CAAC,CAAC;KACJ,MAAM;QACL,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KAChB;AACH,CAAC;AAEK,SAAU,OAAO,CACrB,OAAoB,EACpB,OAAkD;IAElD,IAAI,OAAO,CAAC,OAAO,CAAC,KAAK,IAAI,EAAE;QAC7B,MAAM,iBAAiB,GAAG,OAAO,CAAC;KACnC;IAED,MAAM,CAAC,GAAY,OAAO,CAAC,OAAO,CAAC,CAAC;IACpC,OAAO,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC;AAC1B,CAAC;AAEK,SAAU,aAAa,CAAa,GAAQ;IAChD,uBAAuB;IACvB,IAAI,GAAG,KAAK,SAAS,EAAE;QACrB,MAAM,KAAK,CAAC,yCAAyC,CAAC,CAAC;KACxD;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAGK,SAAU,uBAAuB;IACrC,MAAM,KAAK,CAAC,yCAAyC,CAAC,CAAC;AACzD,CAAC;AAEK,SAAU,WAAW,CAAC,GAAqB;IAC/C,OAAO,GAAG,CAAC,MAAM,CAAC,KAAK,WAAW,CAAC;AACrC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 520, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 526, "column": 0}, "map": {"version":3,"file":"character-classes.js","sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40chevrotain/regexp-to-ast/src/character-classes.ts"],"sourcesContent":["import { cc } from \"./utils.js\";\n\nexport const digitsCharCodes: number[] = [];\nfor (let i = cc(\"0\"); i <= cc(\"9\"); i++) {\n  digitsCharCodes.push(i);\n}\n\nexport const wordCharCodes: number[] = [cc(\"_\")].concat(digitsCharCodes);\nfor (let i = cc(\"a\"); i <= cc(\"z\"); i++) {\n  wordCharCodes.push(i);\n}\n\nfor (let i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n  wordCharCodes.push(i);\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\nexport const whitespaceCodes: number[] = [\n  cc(\" \"),\n  cc(\"\\f\"),\n  cc(\"\\n\"),\n  cc(\"\\r\"),\n  cc(\"\\t\"),\n  cc(\"\\v\"),\n  cc(\"\\t\"),\n  cc(\"\\u00a0\"),\n  cc(\"\\u1680\"),\n  cc(\"\\u2000\"),\n  cc(\"\\u2001\"),\n  cc(\"\\u2002\"),\n  cc(\"\\u2003\"),\n  cc(\"\\u2004\"),\n  cc(\"\\u2005\"),\n  cc(\"\\u2006\"),\n  cc(\"\\u2007\"),\n  cc(\"\\u2008\"),\n  cc(\"\\u2009\"),\n  cc(\"\\u200a\"),\n  cc(\"\\u2028\"),\n  cc(\"\\u2029\"),\n  cc(\"\\u202f\"),\n  cc(\"\\u205f\"),\n  cc(\"\\u3000\"),\n  cc(\"\\ufeff\"),\n];\n"],"names":[],"mappings":";;;;;AAAA,OAAO,EAAE,EAAE,EAAE,MAAM,YAAY,CAAC;;AAEzB,MAAM,eAAe,GAAa,EAAE,CAAC;AAC5C,IAAK,IAAI,CAAC,qLAAG,KAAA,AAAE,EAAC,GAAG,CAAC,EAAE,CAAC,sLAAI,KAAA,AAAE,EAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAE;IACvC,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;CACzB;AAEM,MAAM,aAAa,GAAa;sLAAC,KAAA,AAAE,EAAC,GAAG,CAAC;CAAC,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC;AACzE,IAAK,IAAI,CAAC,OAAG,mLAAA,AAAE,EAAC,GAAG,CAAC,EAAE,CAAC,sLAAI,KAAA,AAAE,EAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAE;IACvC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;CACvB;AAED,IAAK,IAAI,CAAC,qLAAG,KAAA,AAAE,EAAC,GAAG,CAAC,EAAE,CAAC,sLAAI,KAAA,AAAE,EAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAE;IACvC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;CACvB;AAGM,MAAM,eAAe,GAAa;sLACvC,KAAA,AAAE,EAAC,GAAG,CAAC;QACP,mLAAA,AAAE,EAAC,IAAI,CAAC;sLACR,KAAA,AAAE,EAAC,IAAI,CAAC;sLACR,KAAA,AAAE,EAAC,IAAI,CAAC;IACR,uLAAA,AAAE,EAAC,IAAI,CAAC;sLACR,KAAA,AAAE,EAAC,IAAI,CAAC;sLACR,KAAA,AAAE,EAAC,IAAI,CAAC;sLACR,KAAA,AAAE,EAAC,QAAQ,CAAC;KACZ,sLAAA,AAAE,EAAC,QAAQ,CAAC;sLACZ,KAAA,AAAE,EAAC,QAAQ,CAAC;QACZ,mLAAA,AAAE,EAAC,QAAQ,CAAC;sLACZ,KAAA,AAAE,EAAC,QAAQ,CAAC;sLACZ,KAAA,AAAE,EAAC,QAAQ,CAAC;KACZ,sLAAA,AAAE,EAAC,QAAQ,CAAC;sLACZ,KAAA,AAAE,EAAC,QAAQ,CAAC;KACZ,sLAAA,AAAE,EAAC,QAAQ,CAAC;sLACZ,KAAA,AAAE,EAAC,QAAQ,CAAC;sLACZ,KAAA,AAAE,EAAC,QAAQ,CAAC;IACZ,uLAAA,AAAE,EAAC,QAAQ,CAAC;sLACZ,KAAA,AAAE,EAAC,QAAQ,CAAC;KACZ,sLAAA,AAAE,EAAC,QAAQ,CAAC;sLACZ,KAAA,AAAE,EAAC,QAAQ,CAAC;sLACZ,KAAA,AAAE,EAAC,QAAQ,CAAC;sLACZ,KAAA,AAAE,EAAC,QAAQ,CAAC;sLACZ,KAAA,AAAE,EAAC,QAAQ,CAAC;sLACZ,KAAA,AAAE,EAAC,QAAQ,CAAC;CACb,CAAC","ignoreList":[0]}},
    {"offset": {"line": 574, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 580, "column": 0}, "map": {"version":3,"file":"regexp-parser.js","sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40chevrotain/regexp-to-ast/src/regexp-parser.ts"],"sourcesContent":["import type {\n  Alternative,\n  Assertion,\n  Atom,\n  Character,\n  Disjunction,\n  Group,\n  GroupBackReference,\n  Location,\n  Quantifier,\n  Range,\n  RegExpFlags,\n  RegExpPattern,\n  Set,\n  Term,\n} from \"../types\";\nimport {\n  addFlag,\n  ASSERT_EXISTS,\n  ASSERT_NEVER_REACH_HERE,\n  cc,\n  insertToSet,\n  isCharacter,\n} from \"./utils.js\";\nimport {\n  digitsCharCodes,\n  whitespaceCodes,\n  wordCharCodes,\n} from \"./character-classes.js\";\n\n// consts and utilities\nconst hexDigitPattern = /[0-9a-fA-F]/;\nconst decimalPattern = /[0-9]/;\nconst decimalPatternNoZero = /[1-9]/;\n\n// https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n// https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\nexport class RegExpParser {\n  protected idx: number = 0;\n  protected input: string = \"\";\n  protected groupIdx: number = 0;\n\n  protected saveState() {\n    return {\n      idx: this.idx,\n      input: this.input,\n      groupIdx: this.groupIdx,\n    };\n  }\n\n  protected restoreState(newState: {\n    idx: number;\n    input: string;\n    groupIdx: number;\n  }) {\n    this.idx = newState.idx;\n    this.input = newState.input;\n    this.groupIdx = newState.groupIdx;\n  }\n\n  public pattern(input: string): RegExpPattern {\n    // parser state\n    this.idx = 0;\n    this.input = input;\n    this.groupIdx = 0;\n\n    this.consumeChar(\"/\");\n    const value = this.disjunction();\n    this.consumeChar(\"/\");\n\n    const flags: RegExpFlags = {\n      type: \"Flags\",\n      loc: { begin: this.idx, end: input.length },\n      global: false,\n      ignoreCase: false,\n      multiLine: false,\n      unicode: false,\n      sticky: false,\n    };\n\n    while (this.isRegExpFlag()) {\n      switch (this.popChar()) {\n        case \"g\":\n          addFlag(flags, \"global\");\n          break;\n        case \"i\":\n          addFlag(flags, \"ignoreCase\");\n          break;\n        case \"m\":\n          addFlag(flags, \"multiLine\");\n          break;\n        case \"u\":\n          addFlag(flags, \"unicode\");\n          break;\n        case \"y\":\n          addFlag(flags, \"sticky\");\n          break;\n      }\n    }\n\n    if (this.idx !== this.input.length) {\n      throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n    }\n    return {\n      type: \"Pattern\",\n      flags: flags,\n      value: value,\n      loc: this.loc(0),\n    };\n  }\n\n  protected disjunction(): Disjunction {\n    const alts = [];\n    const begin = this.idx;\n\n    alts.push(this.alternative());\n\n    while (this.peekChar() === \"|\") {\n      this.consumeChar(\"|\");\n      alts.push(this.alternative());\n    }\n\n    return { type: \"Disjunction\", value: alts, loc: this.loc(begin) };\n  }\n\n  protected alternative(): Alternative {\n    const terms = [];\n    const begin = this.idx;\n\n    while (this.isTerm()) {\n      terms.push(this.term());\n    }\n\n    return { type: \"Alternative\", value: terms, loc: this.loc(begin) };\n  }\n\n  protected term(): Term {\n    if (this.isAssertion()) {\n      return this.assertion();\n    } else {\n      return this.atom();\n    }\n  }\n\n  protected assertion(): Assertion {\n    const begin = this.idx;\n    switch (this.popChar()) {\n      case \"^\":\n        return {\n          type: \"StartAnchor\",\n          loc: this.loc(begin),\n        };\n      case \"$\":\n        return { type: \"EndAnchor\", loc: this.loc(begin) };\n      // '\\b' or '\\B'\n      case \"\\\\\":\n        switch (this.popChar()) {\n          case \"b\":\n            return {\n              type: \"WordBoundary\",\n              loc: this.loc(begin),\n            };\n          case \"B\":\n            return {\n              type: \"NonWordBoundary\",\n              loc: this.loc(begin),\n            };\n        }\n        // istanbul ignore next\n        throw Error(\"Invalid Assertion Escape\");\n      // '(?=' or '(?!'\n      case \"(\":\n        this.consumeChar(\"?\");\n\n        let type: \"Lookahead\" | \"NegativeLookahead\" | undefined;\n        switch (this.popChar()) {\n          case \"=\":\n            type = \"Lookahead\";\n            break;\n          case \"!\":\n            type = \"NegativeLookahead\";\n            break;\n        }\n        ASSERT_EXISTS(type);\n\n        const disjunction = this.disjunction();\n\n        this.consumeChar(\")\");\n\n        return {\n          type: type!,\n          value: disjunction,\n          loc: this.loc(begin),\n        };\n    }\n    // istanbul ignore next\n    return ASSERT_NEVER_REACH_HERE();\n  }\n\n  protected quantifier(\n    isBacktracking: boolean = false,\n  ): Quantifier | undefined {\n    let range: Partial<Quantifier> | undefined = undefined;\n    const begin = this.idx;\n    switch (this.popChar()) {\n      case \"*\":\n        range = {\n          atLeast: 0,\n          atMost: Infinity,\n        };\n        break;\n      case \"+\":\n        range = {\n          atLeast: 1,\n          atMost: Infinity,\n        };\n        break;\n      case \"?\":\n        range = {\n          atLeast: 0,\n          atMost: 1,\n        };\n        break;\n      case \"{\":\n        const atLeast = this.integerIncludingZero();\n        switch (this.popChar()) {\n          case \"}\":\n            range = {\n              atLeast: atLeast,\n              atMost: atLeast,\n            };\n            break;\n          case \",\":\n            let atMost;\n            if (this.isDigit()) {\n              atMost = this.integerIncludingZero();\n              range = {\n                atLeast: atLeast,\n                atMost: atMost,\n              };\n            } else {\n              range = {\n                atLeast: atLeast,\n                atMost: Infinity,\n              };\n            }\n            this.consumeChar(\"}\");\n            break;\n        }\n        // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n        // causes severe performance degradations\n        if (isBacktracking === true && range === undefined) {\n          return undefined;\n        }\n        ASSERT_EXISTS(range);\n        break;\n    }\n\n    // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n    // causes severe performance degradations\n    if (isBacktracking === true && range === undefined) {\n      return undefined;\n    }\n\n    // istanbul ignore else\n    if (ASSERT_EXISTS(range)) {\n      if (this.peekChar(0) === \"?\") {\n        this.consumeChar(\"?\");\n        range.greedy = false;\n      } else {\n        range.greedy = true;\n      }\n\n      range.type = \"Quantifier\";\n      range.loc = this.loc(begin);\n      return range as Quantifier;\n    }\n  }\n\n  protected atom(): Atom {\n    let atom: Omit<Atom, \"loc\" | \"type\"> | undefined;\n    const begin = this.idx;\n    switch (this.peekChar()) {\n      case \".\":\n        atom = this.dotAll();\n        break;\n      case \"\\\\\":\n        atom = this.atomEscape();\n        break;\n      case \"[\":\n        atom = this.characterClass();\n        break;\n      case \"(\":\n        atom = this.group();\n        break;\n    }\n\n    if (atom === undefined && this.isPatternCharacter()) {\n      atom = this.patternCharacter();\n    }\n\n    // istanbul ignore else\n    if (ASSERT_EXISTS<Atom>(atom)) {\n      atom.loc = this.loc(begin);\n\n      if (this.isQuantifier()) {\n        atom.quantifier = this.quantifier();\n      }\n\n      return atom;\n    }\n\n    // istanbul ignore next\n    return ASSERT_NEVER_REACH_HERE();\n  }\n\n  protected dotAll(): Omit<Set, \"loc\"> {\n    this.consumeChar(\".\");\n    return {\n      type: \"Set\",\n      complement: true,\n      value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")],\n    };\n  }\n\n  protected atomEscape(): Omit<GroupBackReference | Set | Character, \"loc\"> {\n    this.consumeChar(\"\\\\\");\n\n    switch (this.peekChar()) {\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        return this.decimalEscapeAtom();\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n      case \"0\":\n        return this.nulCharacterAtom();\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n      default:\n        return this.identityEscapeAtom();\n    }\n  }\n\n  protected decimalEscapeAtom(): Omit<GroupBackReference, \"loc\"> {\n    const value = this.positiveInteger();\n\n    return { type: \"GroupBackReference\", value: value };\n  }\n\n  protected characterClassEscape(): Omit<Set, \"loc\"> {\n    let set: (number | Range)[] | undefined;\n    let complement = false;\n    switch (this.popChar()) {\n      case \"d\":\n        set = digitsCharCodes;\n        break;\n      case \"D\":\n        set = digitsCharCodes;\n        complement = true;\n        break;\n      case \"s\":\n        set = whitespaceCodes;\n        break;\n      case \"S\":\n        set = whitespaceCodes;\n        complement = true;\n        break;\n      case \"w\":\n        set = wordCharCodes;\n        break;\n      case \"W\":\n        set = wordCharCodes;\n        complement = true;\n        break;\n    }\n\n    // istanbul ignore else\n    if (ASSERT_EXISTS(set)) {\n      return { type: \"Set\", value: set, complement: complement };\n    }\n    // istanbul ignore next\n    return ASSERT_NEVER_REACH_HERE();\n  }\n\n  protected controlEscapeAtom(): Omit<Character, \"loc\"> {\n    let escapeCode;\n    switch (this.popChar()) {\n      case \"f\":\n        escapeCode = cc(\"\\f\");\n        break;\n      case \"n\":\n        escapeCode = cc(\"\\n\");\n        break;\n      case \"r\":\n        escapeCode = cc(\"\\r\");\n        break;\n      case \"t\":\n        escapeCode = cc(\"\\t\");\n        break;\n      case \"v\":\n        escapeCode = cc(\"\\v\");\n        break;\n    }\n\n    // istanbul ignore else\n    if (ASSERT_EXISTS(escapeCode)) {\n      return { type: \"Character\", value: escapeCode };\n    }\n    // istanbul ignore next\n    return ASSERT_NEVER_REACH_HERE();\n  }\n\n  protected controlLetterEscapeAtom(): Omit<Character, \"loc\"> {\n    this.consumeChar(\"c\");\n    const letter = this.popChar();\n    if (/[a-zA-Z]/.test(letter) === false) {\n      throw Error(\"Invalid \");\n    }\n\n    const letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n    return { type: \"Character\", value: letterCode };\n  }\n\n  protected nulCharacterAtom(): Omit<Character, \"loc\"> {\n    // TODO implement '[lookahead ∉ DecimalDigit]'\n    // TODO: for the deprecated octal escape sequence\n    this.consumeChar(\"0\");\n    return { type: \"Character\", value: cc(\"\\0\") };\n  }\n\n  protected hexEscapeSequenceAtom(): Omit<Character, \"loc\"> {\n    this.consumeChar(\"x\");\n    return this.parseHexDigits(2);\n  }\n\n  protected regExpUnicodeEscapeSequenceAtom(): Omit<Character, \"loc\"> {\n    this.consumeChar(\"u\");\n    return this.parseHexDigits(4);\n  }\n\n  protected identityEscapeAtom(): Omit<Character, \"loc\"> {\n    // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n    // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n    const escapedChar = this.popChar();\n    return { type: \"Character\", value: cc(escapedChar) };\n  }\n\n  protected classPatternCharacterAtom(): Omit<Character, \"loc\"> {\n    switch (this.peekChar()) {\n      // istanbul ignore next\n      case \"\\n\":\n      // istanbul ignore next\n      case \"\\r\":\n      // istanbul ignore next\n      case \"\\u2028\":\n      // istanbul ignore next\n      case \"\\u2029\":\n      // istanbul ignore next\n      case \"\\\\\":\n      // istanbul ignore next\n      case \"]\":\n        throw Error(\"TBD\");\n      default:\n        const nextChar = this.popChar();\n        return { type: \"Character\", value: cc(nextChar) };\n    }\n  }\n\n  protected characterClass(): Omit<Set, \"loc\"> {\n    const set: (number | Range)[] = [];\n    let complement = false;\n    this.consumeChar(\"[\");\n    if (this.peekChar(0) === \"^\") {\n      this.consumeChar(\"^\");\n      complement = true;\n    }\n\n    while (this.isClassAtom()) {\n      const from = this.classAtom();\n      const isFromSingleChar = from.type === \"Character\";\n      if (isCharacter(from) && this.isRangeDash()) {\n        this.consumeChar(\"-\");\n        const to = this.classAtom();\n        const isToSingleChar = to.type === \"Character\";\n\n        // a range can only be used when both sides are single characters\n        if (isCharacter(to)) {\n          if (to.value < from.value) {\n            throw Error(\"Range out of order in character class\");\n          }\n          set.push({ from: from.value, to: to.value });\n        } else {\n          // literal dash\n          insertToSet(from.value, set);\n          set.push(cc(\"-\"));\n          insertToSet(to.value, set);\n        }\n      } else {\n        insertToSet(from.value, set);\n      }\n    }\n\n    this.consumeChar(\"]\");\n\n    return { type: \"Set\", complement: complement, value: set };\n  }\n\n  protected classAtom(): Omit<Character | Set, \"loc\"> {\n    switch (this.peekChar()) {\n      // istanbul ignore next\n      case \"]\":\n      // istanbul ignore next\n      case \"\\n\":\n      // istanbul ignore next\n      case \"\\r\":\n      // istanbul ignore next\n      case \"\\u2028\":\n      // istanbul ignore next\n      case \"\\u2029\":\n        throw Error(\"TBD\");\n      case \"\\\\\":\n        return this.classEscape();\n      default:\n        return this.classPatternCharacterAtom();\n    }\n  }\n\n  protected classEscape(): Omit<Character | Set, \"loc\"> {\n    this.consumeChar(\"\\\\\");\n    switch (this.peekChar()) {\n      // Matches a backspace.\n      // (Not to be confused with \\b word boundary outside characterClass)\n      case \"b\":\n        this.consumeChar(\"b\");\n        return { type: \"Character\", value: cc(\"\\u0008\") };\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n      case \"0\":\n        return this.nulCharacterAtom();\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n      default:\n        return this.identityEscapeAtom();\n    }\n  }\n\n  protected group(): Omit<Group, \"loc\"> {\n    let capturing = true;\n    this.consumeChar(\"(\");\n    switch (this.peekChar(0)) {\n      case \"?\":\n        this.consumeChar(\"?\");\n        this.consumeChar(\":\");\n        capturing = false;\n        break;\n      default:\n        this.groupIdx++;\n        break;\n    }\n    const value = this.disjunction();\n    this.consumeChar(\")\");\n\n    const groupAst: Omit<Group, \"loc\"> = {\n      type: \"Group\",\n      capturing: capturing,\n      value: value,\n    };\n\n    if (capturing) {\n      groupAst[\"idx\"] = this.groupIdx;\n    }\n\n    return groupAst;\n  }\n\n  protected positiveInteger(): number {\n    let number = this.popChar();\n\n    // istanbul ignore next - can't ever get here due to previous lookahead checks\n    // still implementing this error checking in case this ever changes.\n    if (decimalPatternNoZero.test(number) === false) {\n      throw Error(\"Expecting a positive integer\");\n    }\n\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n\n    return parseInt(number, 10);\n  }\n\n  protected integerIncludingZero(): number {\n    let number = this.popChar();\n    if (decimalPattern.test(number) === false) {\n      throw Error(\"Expecting an integer\");\n    }\n\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n\n    return parseInt(number, 10);\n  }\n\n  protected patternCharacter(): Omit<Character, \"loc\"> {\n    const nextChar = this.popChar();\n    switch (nextChar) {\n      // istanbul ignore next\n      case \"\\n\":\n      // istanbul ignore next\n      case \"\\r\":\n      // istanbul ignore next\n      case \"\\u2028\":\n      // istanbul ignore next\n      case \"\\u2029\":\n      // istanbul ignore next\n      case \"^\":\n      // istanbul ignore next\n      case \"$\":\n      // istanbul ignore next\n      case \"\\\\\":\n      // istanbul ignore next\n      case \".\":\n      // istanbul ignore next\n      case \"*\":\n      // istanbul ignore next\n      case \"+\":\n      // istanbul ignore next\n      case \"?\":\n      // istanbul ignore next\n      case \"(\":\n      // istanbul ignore next\n      case \")\":\n      // istanbul ignore next\n      case \"[\":\n      // istanbul ignore next\n      case \"|\":\n        // istanbul ignore next\n        throw Error(\"TBD\");\n      default:\n        return { type: \"Character\", value: cc(nextChar) };\n    }\n  }\n  protected isRegExpFlag(): boolean {\n    switch (this.peekChar(0)) {\n      case \"g\":\n      case \"i\":\n      case \"m\":\n      case \"u\":\n      case \"y\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  protected isRangeDash(): boolean {\n    return this.peekChar() === \"-\" && this.isClassAtom(1);\n  }\n\n  protected isDigit(): boolean {\n    return decimalPattern.test(this.peekChar(0));\n  }\n\n  protected isClassAtom(howMuch = 0): boolean {\n    switch (this.peekChar(howMuch)) {\n      case \"]\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n      default:\n        return true;\n    }\n  }\n\n  protected isTerm() {\n    return this.isAtom() || this.isAssertion();\n  }\n\n  protected isAtom(): boolean {\n    if (this.isPatternCharacter()) {\n      return true;\n    }\n\n    switch (this.peekChar(0)) {\n      case \".\":\n      case \"\\\\\": // atomEscape\n      case \"[\": // characterClass\n      // TODO: isAtom must be called before isAssertion - disambiguate\n      case \"(\": // group\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  protected isAssertion(): boolean {\n    switch (this.peekChar(0)) {\n      case \"^\":\n      case \"$\":\n        return true;\n      // '\\b' or '\\B'\n      case \"\\\\\":\n        switch (this.peekChar(1)) {\n          case \"b\":\n          case \"B\":\n            return true;\n          default:\n            return false;\n        }\n      // '(?=' or '(?!'\n      case \"(\":\n        return (\n          this.peekChar(1) === \"?\" &&\n          (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\")\n        );\n      default:\n        return false;\n    }\n  }\n\n  protected isQuantifier(): boolean {\n    const prevState = this.saveState();\n    try {\n      return this.quantifier(true) !== undefined;\n    } catch (e) {\n      return false;\n    } finally {\n      this.restoreState(prevState);\n    }\n  }\n\n  protected isPatternCharacter(): boolean {\n    switch (this.peekChar()) {\n      case \"^\":\n      case \"$\":\n      case \"\\\\\":\n      case \".\":\n      case \"*\":\n      case \"+\":\n      case \"?\":\n      case \"(\":\n      case \")\":\n      case \"[\":\n      case \"|\":\n      case \"/\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n      default:\n        return true;\n    }\n  }\n\n  protected parseHexDigits(howMany: number): Omit<Character, \"loc\"> {\n    let hexString = \"\";\n    for (let i = 0; i < howMany; i++) {\n      const hexChar = this.popChar();\n      if (hexDigitPattern.test(hexChar) === false) {\n        throw Error(\"Expecting a HexDecimal digits\");\n      }\n      hexString += hexChar;\n    }\n    const charCode = parseInt(hexString, 16);\n    return { type: \"Character\", value: charCode };\n  }\n\n  protected peekChar(howMuch = 0): string {\n    return this.input[this.idx + howMuch];\n  }\n\n  protected popChar(): string {\n    const nextChar = this.peekChar(0);\n    this.consumeChar(undefined);\n    return nextChar;\n  }\n\n  protected consumeChar(char: string | undefined): void {\n    if (char !== undefined && this.input[this.idx] !== char) {\n      throw Error(\n        \"Expected: '\" +\n          char +\n          \"' but found: '\" +\n          this.input[this.idx] +\n          \"' at offset: \" +\n          this.idx,\n      );\n    }\n\n    if (this.idx >= this.input.length) {\n      throw Error(\"Unexpected end of input\");\n    }\n    this.idx++;\n  }\n\n  protected loc(begin: number): Location {\n    return { begin: begin, end: this.idx };\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1360, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1366, "column": 0}, "map": {"version":3,"file":"base-regexp-visitor.js","sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40chevrotain/regexp-to-ast/src/base-regexp-visitor.ts"],"sourcesContent":["import type {\n  Alternative,\n  Assertion,\n  Character,\n  Disjunction,\n  Group,\n  GroupBackReference,\n  IRegExpAST,\n  Quantifier,\n  RegExpAstPart,\n  RegExpFlags,\n  RegExpPattern,\n  Set,\n} from \"../types\";\n\nexport class BaseRegExpVisitor {\n  public visitChildren(node: IRegExpAST) {\n    for (const key in node) {\n      const child = (node as any)[key];\n      /* istanbul ignore else */\n      if (node.hasOwnProperty(key)) {\n        if (child.type !== undefined) {\n          this.visit(child);\n        } else if (Array.isArray(child)) {\n          child.forEach((subChild) => {\n            this.visit(subChild);\n          }, this);\n        }\n      }\n    }\n  }\n\n  public visit(node: RegExpAstPart): void {\n    switch (node.type) {\n      case \"Pattern\":\n        this.visitPattern(node);\n        break;\n      case \"Flags\":\n        this.visitFlags(node);\n        break;\n      case \"Disjunction\":\n        this.visitDisjunction(node);\n        break;\n      case \"Alternative\":\n        this.visitAlternative(node);\n        break;\n      case \"StartAnchor\":\n        this.visitStartAnchor(node);\n        break;\n      case \"EndAnchor\":\n        this.visitEndAnchor(node);\n        break;\n      case \"WordBoundary\":\n        this.visitWordBoundary(node);\n        break;\n      case \"NonWordBoundary\":\n        this.visitNonWordBoundary(node);\n        break;\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        break;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        break;\n      case \"Character\":\n        this.visitCharacter(node);\n        break;\n      case \"Set\":\n        this.visitSet(node);\n        break;\n      case \"Group\":\n        this.visitGroup(node);\n        break;\n      case \"GroupBackReference\":\n        this.visitGroupBackReference(node);\n        break;\n      case \"Quantifier\":\n        this.visitQuantifier(node);\n        break;\n    }\n\n    this.visitChildren(node);\n  }\n\n  public visitPattern(node: RegExpPattern): void {}\n\n  public visitFlags(node: RegExpFlags): void {}\n\n  public visitDisjunction(node: Disjunction): void {}\n\n  public visitAlternative(node: Alternative): void {}\n\n  // Assertion\n  public visitStartAnchor(node: Assertion): void {}\n\n  public visitEndAnchor(node: Assertion): void {}\n\n  public visitWordBoundary(node: Assertion): void {}\n\n  public visitNonWordBoundary(node: Assertion): void {}\n\n  public visitLookahead(node: Assertion): void {}\n\n  public visitNegativeLookahead(node: Assertion): void {}\n\n  // atoms\n  public visitCharacter(node: Character): void {}\n\n  public visitSet(node: Set): void {}\n\n  public visitGroup(node: Group): void {}\n\n  public visitGroupBackReference(node: GroupBackReference): void {}\n\n  public visitQuantifier(node: Quantifier): void {}\n}\n"],"names":[],"mappings":";;;AAeM,MAAO,iBAAiB;IACrB,aAAa,CAAC,IAAgB,EAAA;QACnC,IAAK,MAAM,GAAG,IAAI,IAAI,CAAE;YACtB,MAAM,KAAK,GAAI,IAAY,CAAC,GAAG,CAAC,CAAC;YACjC,wBAAA,EAA0B,CAC1B,IAAI,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;gBAC5B,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE;oBAC5B,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;iBACnB,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;oBAC/B,KAAK,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE;wBACzB,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;oBACvB,CAAC,EAAE,IAAI,CAAC,CAAC;iBACV;aACF;SACF;IACH,CAAC;IAEM,KAAK,CAAC,IAAmB,EAAA;QAC9B,OAAQ,IAAI,CAAC,IAAI,EAAE;YACjB,KAAK,SAAS;gBACZ,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;gBACxB,MAAM;YACR,KAAK,OAAO;gBACV,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;gBACtB,MAAM;YACR,KAAK,aAAa;gBAChB,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;gBAC5B,MAAM;YACR,KAAK,aAAa;gBAChB,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;gBAC5B,MAAM;YACR,KAAK,aAAa;gBAChB,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;gBAC5B,MAAM;YACR,KAAK,WAAW;gBACd,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;gBAC1B,MAAM;YACR,KAAK,cAAc;gBACjB,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;gBAC7B,MAAM;YACR,KAAK,iBAAiB;gBACpB,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;gBAChC,MAAM;YACR,KAAK,WAAW;gBACd,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;gBAC1B,MAAM;YACR,KAAK,mBAAmB;gBACtB,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,CAAC;gBAClC,MAAM;YACR,KAAK,WAAW;gBACd,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;gBAC1B,MAAM;YACR,KAAK,KAAK;gBACR,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gBACpB,MAAM;YACR,KAAK,OAAO;gBACV,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;gBACtB,MAAM;YACR,KAAK,oBAAoB;gBACvB,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;gBACnC,MAAM;YACR,KAAK,YAAY;gBACf,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;gBAC3B,MAAM;SACT;QAED,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;IAEM,YAAY,CAAC,IAAmB,EAAA,CAAS,CAAC;IAE1C,UAAU,CAAC,IAAiB,EAAA,CAAS,CAAC;IAEtC,gBAAgB,CAAC,IAAiB,EAAA,CAAS,CAAC;IAE5C,gBAAgB,CAAC,IAAiB,EAAA,CAAS,CAAC;IAEnD,YAAY;IACL,gBAAgB,CAAC,IAAe,EAAA,CAAS,CAAC;IAE1C,cAAc,CAAC,IAAe,EAAA,CAAS,CAAC;IAExC,iBAAiB,CAAC,IAAe,EAAA,CAAS,CAAC;IAE3C,oBAAoB,CAAC,IAAe,EAAA,CAAS,CAAC;IAE9C,cAAc,CAAC,IAAe,EAAA,CAAS,CAAC;IAExC,sBAAsB,CAAC,IAAe,EAAA,CAAS,CAAC;IAEvD,QAAQ;IACD,cAAc,CAAC,IAAe,EAAA,CAAS,CAAC;IAExC,QAAQ,CAAC,IAAS,EAAA,CAAS,CAAC;IAE5B,UAAU,CAAC,IAAW,EAAA,CAAS,CAAC;IAEhC,uBAAuB,CAAC,IAAwB,EAAA,CAAS,CAAC;IAE1D,eAAe,CAAC,IAAgB,EAAA,CAAS,CAAC;CAClD","ignoreList":[0]}},
    {"offset": {"line": 1452, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1458, "column": 0}, "map": {"version":3,"file":"api.js","sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40chevrotain/regexp-to-ast/src/api.ts"],"sourcesContent":["export { RegExpParser } from \"./regexp-parser.js\";\nexport { BaseRegExpVisitor } from \"./base-regexp-visitor.js\";\n"],"names":[],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 1462, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1478, "column": 0}, "map": {"version":3,"file":"model.js","sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40chevrotain/cst-dts-gen/src/model.ts"],"sourcesContent":["import type {\n  Alternation,\n  Alternative,\n  IProduction,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal,\n  TokenType,\n} from \"@chevrotain/types\";\nimport { GAstVisitor, NonTerminal } from \"@chevrotain/gast\";\nimport { assign, flatten, groupBy, map, some, values } from \"lodash-es\";\n\nexport function buildModel(\n  productions: Record<string, Rule>,\n): CstNodeTypeDefinition[] {\n  const generator = new CstNodeDefinitionGenerator();\n  const allRules = values(productions);\n  return map(allRules, (rule) => generator.visitRule(rule));\n}\n\nexport type CstNodeTypeDefinition = {\n  name: string;\n  properties: PropertyTypeDefinition[];\n};\n\nexport type PropertyTypeDefinition = {\n  name: string;\n  type: PropertyArrayType;\n  optional: boolean;\n};\n\nexport type PropertyArrayType =\n  | TokenArrayType\n  | RuleArrayType\n  | (TokenArrayType | RuleArrayType)[];\n\nexport type TokenArrayType = { kind: \"token\" };\nexport type RuleArrayType = {\n  kind: \"rule\";\n  name: string;\n};\n\nclass CstNodeDefinitionGenerator extends GAstVisitor {\n  visitRule(node: Rule): CstNodeTypeDefinition {\n    const rawElements = this.visitEach(node.definition);\n\n    const grouped = groupBy(rawElements, (el) => el.propertyName);\n    const properties = map(grouped, (group, propertyName) => {\n      const allNullable = !some(group, (el) => !el.canBeNull);\n\n      // In an alternation with a label a property name can have\n      // multiple types.\n      let propertyType: PropertyArrayType = group[0].type;\n      if (group.length > 1) {\n        propertyType = map(group, (g) => g.type);\n      }\n\n      return {\n        name: propertyName,\n        type: propertyType,\n        optional: allNullable,\n      } as PropertyTypeDefinition;\n    });\n\n    return {\n      name: node.name,\n      properties: properties,\n    };\n  }\n\n  visitAlternative(node: Alternative) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n  }\n\n  visitOption(node: Option) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n  }\n\n  visitRepetition(node: Repetition) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n  }\n\n  visitRepetitionMandatory(node: RepetitionMandatory) {\n    return this.visitEach(node.definition);\n  }\n\n  visitRepetitionMandatoryWithSeparator(\n    node: RepetitionMandatoryWithSeparator,\n  ) {\n    return this.visitEach(node.definition).concat({\n      propertyName: node.separator.name,\n      canBeNull: true,\n      type: getType(node.separator),\n    });\n  }\n\n  visitRepetitionWithSeparator(node: RepetitionWithSeparator) {\n    return this.visitEachAndOverrideWith(node.definition, {\n      canBeNull: true,\n    }).concat({\n      propertyName: node.separator.name,\n      canBeNull: true,\n      type: getType(node.separator),\n    });\n  }\n\n  visitAlternation(node: Alternation) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n  }\n\n  visitTerminal(node: Terminal): PropertyTupleElement[] {\n    return [\n      {\n        propertyName: node.label || node.terminalType.name,\n        canBeNull: false,\n        type: getType(node),\n      },\n    ];\n  }\n\n  visitNonTerminal(node: NonTerminal): PropertyTupleElement[] {\n    return [\n      {\n        propertyName: node.label || node.nonTerminalName,\n        canBeNull: false,\n        type: getType(node),\n      },\n    ];\n  }\n\n  private visitEachAndOverrideWith(\n    definition: IProduction[],\n    override: Partial<PropertyTupleElement>,\n  ) {\n    return map(\n      this.visitEach(definition),\n      (definition) => assign({}, definition, override) as PropertyTupleElement,\n    );\n  }\n\n  private visitEach(definition: IProduction[]) {\n    return flatten<PropertyTupleElement>(\n      map(\n        definition,\n        (definition) => this.visit(definition) as PropertyTupleElement[],\n      ),\n    );\n  }\n}\n\ntype PropertyTupleElement = {\n  propertyName: string;\n  canBeNull: boolean;\n  type: TokenArrayType | RuleArrayType;\n};\n\nfunction getType(\n  production: Terminal | NonTerminal | TokenType,\n): TokenArrayType | RuleArrayType {\n  if (production instanceof NonTerminal) {\n    return {\n      kind: \"rule\",\n      name: production.referencedRule.name,\n    };\n  }\n\n  return { kind: \"token\" };\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1595, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1601, "column": 0}, "map": {"version":3,"file":"generate.js","sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40chevrotain/cst-dts-gen/src/generate.ts"],"sourcesContent":["import { flatten, isArray, map, reduce, uniq, upperFirst } from \"lodash-es\";\nimport { GenerateDtsOptions } from \"@chevrotain/types\";\nimport {\n  CstNodeTypeDefinition,\n  PropertyArrayType,\n  PropertyTypeDefinition,\n  RuleArrayType,\n  TokenArrayType,\n} from \"./model.js\";\n\nexport function genDts(\n  model: CstNodeTypeDefinition[],\n  options: Required<GenerateDtsOptions>,\n): string {\n  let contentParts: string[] = [];\n\n  contentParts = contentParts.concat(\n    `import type { CstNode, ICstVisitor, IToken } from \"chevrotain\";`,\n  );\n\n  contentParts = contentParts.concat(\n    flatten(map(model, (node) => genCstNodeTypes(node))),\n  );\n\n  if (options.includeVisitorInterface) {\n    contentParts = contentParts.concat(\n      genVisitor(options.visitorInterfaceName, model),\n    );\n  }\n\n  return contentParts.join(\"\\n\\n\") + \"\\n\";\n}\n\nfunction genCstNodeTypes(node: CstNodeTypeDefinition) {\n  const nodeCstInterface = genNodeInterface(node);\n  const nodeChildrenInterface = genNodeChildrenType(node);\n\n  return [nodeCstInterface, nodeChildrenInterface];\n}\n\nfunction genNodeInterface(node: CstNodeTypeDefinition) {\n  const nodeInterfaceName = getNodeInterfaceName(node.name);\n  const childrenTypeName = getNodeChildrenTypeName(node.name);\n\n  return `export interface ${nodeInterfaceName} extends CstNode {\n  name: \"${node.name}\";\n  children: ${childrenTypeName};\n}`;\n}\n\nfunction genNodeChildrenType(node: CstNodeTypeDefinition) {\n  const typeName = getNodeChildrenTypeName(node.name);\n\n  return `export type ${typeName} = {\n  ${map(node.properties, (property) => genChildProperty(property)).join(\"\\n  \")}\n};`;\n}\n\nfunction genChildProperty(prop: PropertyTypeDefinition) {\n  const typeName = buildTypeString(prop.type);\n  return `${prop.name}${prop.optional ? \"?\" : \"\"}: ${typeName}[];`;\n}\n\nfunction genVisitor(name: string, nodes: CstNodeTypeDefinition[]) {\n  return `export interface ${name}<IN, OUT> extends ICstVisitor<IN, OUT> {\n  ${map(nodes, (node) => genVisitorFunction(node)).join(\"\\n  \")}\n}`;\n}\n\nfunction genVisitorFunction(node: CstNodeTypeDefinition) {\n  const childrenTypeName = getNodeChildrenTypeName(node.name);\n  return `${node.name}(children: ${childrenTypeName}, param?: IN): OUT;`;\n}\n\nfunction buildTypeString(type: PropertyArrayType) {\n  if (isArray(type)) {\n    const typeNames = uniq(map(type, (t) => getTypeString(t)));\n    const typeString = reduce(typeNames, (sum, t) => sum + \" | \" + t);\n    return \"(\" + typeString + \")\";\n  } else {\n    return getTypeString(type);\n  }\n}\n\nfunction getTypeString(type: TokenArrayType | RuleArrayType) {\n  if (type.kind === \"token\") {\n    return \"IToken\";\n  }\n  return getNodeInterfaceName(type.name);\n}\n\nfunction getNodeInterfaceName(ruleName: string) {\n  return upperFirst(ruleName) + \"CstNode\";\n}\n\nfunction getNodeChildrenTypeName(ruleName: string) {\n  return upperFirst(ruleName) + \"CstChildren\";\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1676, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1682, "column": 0}, "map": {"version":3,"file":"api.js","sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40chevrotain/cst-dts-gen/src/api.ts"],"sourcesContent":["import { GenerateDtsOptions, Rule } from \"@chevrotain/types\";\nimport { buildModel } from \"./model.js\";\nimport { genDts } from \"./generate.js\";\n\nconst defaultOptions: Required<GenerateDtsOptions> = {\n  includeVisitorInterface: true,\n  visitorInterfaceName: \"ICstNodeVisitor\",\n};\n\nexport function generateCstDts(\n  productions: Record<string, Rule>,\n  options?: GenerateDtsOptions,\n): string {\n  const effectiveOptions = {\n    ...defaultOptions,\n    ...options,\n  };\n\n  const model = buildModel(productions);\n\n  return genDts(model, effectiveOptions);\n}\n"],"names":[],"mappings":";;;AACA,OAAO,EAAE,UAAU,EAAE,MAAM,YAAY,CAAC;AACxC,OAAO,EAAE,MAAM,EAAE,MAAM,eAAe,CAAC;;;AAEvC,MAAM,cAAc,GAAiC;IACnD,uBAAuB,EAAE,IAAI;IAC7B,oBAAoB,EAAE,iBAAiB;CACxC,CAAC;AAEI,SAAU,cAAc,CAC5B,WAAiC,EACjC,OAA4B;IAE5B,MAAM,gBAAgB,GAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACjB,cAAc,GACd,OAAO,CACX,CAAC;IAEF,MAAM,KAAK,mLAAG,aAAA,AAAU,EAAC,WAAW,CAAC,CAAC;IAEtC,0LAAO,SAAA,AAAM,EAAC,KAAK,EAAE,gBAAgB,CAAC,CAAC;AACzC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1698, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1704, "column": 0}, "map": {"version":3,"sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/riscript/src/riscript.js","file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/riscript/src/parser.js","file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/riscript/src/util.js","file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/riscript/src/visitor.js","file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/riscript/src/tokens.js","file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/riscript/src/grammar.js"],"sourcesContent":["/** @module riscript */\n\nimport he from 'he';\nimport { Query } from 'mingo';\nimport { Lexer } from 'chevrotain';\n\nimport { RiScriptParser } from './parser.js';\nimport { RiScriptVisitor } from './visitor.js';\nimport { getTokens, TextTypes } from './tokens.js';\nimport { RiGrammar } from './grammar.js';\nimport { Util } from './util.js';\n\nconst { decode } = he;\nconst Vowels = /[aeiou]/;\nconst HtmlEntities = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi;\nconst { escapeText, slashEscToEntities, escapeMarkdownLink, escapeJSONRegex } = Util;\n\n/** @private */\nclass RiQuery extends Query {\n\n  constructor(scripting, condition, options) {\n\n    if (typeof condition !== 'string') {\n      try {\n        condition = JSON.stringify(condition);\n      }\n      catch (e) {\n        throw Error(condition.toString().includes('@') ?\n          'Replace @ with $ when passing an object to RiQuery\\nRoot: ' + e : e);\n      }\n    }\n\n    if (!condition.includes('$')) throw Error('Invalid Gate: \\''\n      + condition + \"' -> operand must include $symbol or $function()\");\n\n    condition = condition.replace(/(\\$|\\(\\))/g, '').replace(/@/g, '$');\n    condition = scripting.parseJSOL(condition);\n    \n    super(condition, options);\n  }\n\n  test(obj) {\n    // @ts-ignore\n    let compiled = this.compiled;\n    for (let i = 0, len = compiled.length; i < len; i++) {\n      if (!compiled[i](obj)) return false;\n    }\n    return true;\n  }\n\n  operands() {\n    // @ts-ignore\n    const stack = [this.condition];\n    const keys = new Set();\n    while (stack?.length > 0) {\n      const currentObj = stack.pop();\n      Object.keys(currentObj).forEach((key) => {\n        const value = currentObj[key];\n        if (!key.startsWith('$')) keys.add(key);\n        if (typeof value === 'object' && value !== null) {\n          const eles = Array.isArray(value) ? value : [value];\n          eles.forEach((ele) => stack.push(ele));\n        }\n      });\n    }\n    return Array.from(keys);\n  }\n}\n\n/**\n * The RiScript interpreter, responsible for lexing, parsing and evaluating \n * RiScript and RiGrammar expressions\n */\nclass RiScript {\n\n  /** @type {string} */\n  static VERSION = '1.1.1';\n\n  /** @type {typeof RiQuery} */\n  static Query = RiQuery;\n\n  /** @type {Object.<string, boolean>} */\n  static RiTaWarnings = { plurals: false, phones: false, silent: false };\n\n  /**\n   * Create a RiTa grammar instance\n   * @param {object} [rules] - the rules of the grammar\n   * @param {object} [context] - the context of the grammar\n   * @param {object} [options] - options for the evaluation\n   * @returns {RiGrammar} - a new RiGrammar instance\n   */\n  static grammar(rules, context, options) {\n    return new RiGrammar(rules, context, options);\n  }\n\n  /**\n   * Evaluates the input script via the RiScript parser\n   * @param {string} script - the script to evaluate\n   * @param {object} [context] - the context (or world-state) to evaluate in\n   * @param {object} [options] - options for the evaluation\n   * @param {object} [options.RiTa] - optionals RiTa object to use in transforms\n   * @param {number} [options.compatibility] - the RiTa compatibility level (pass 2 for v2)\n   * @param {boolean} [options.trace=false] - whether to trace the evaluation\n   * @returns {string} - the evaluated script\n   */\n  static evaluate(script, context, options = {}) {\n    return new RiScript(options).evaluate(script, context, options);\n  }\n\n  /**\n   * Creates a new RiScript instance\n   * @param {object} [options] - options for the object\n   * @param {object} [options.RiTa] - optionals RiTa object to use in transforms\n   * @param {number} [options.compatibility] - the RiTa compatibility level\n   */\n  constructor(options = {}) {\n\n    /** @type {Object.<string, any>} */ this.Escaped = undefined\n    /** @type {Object.<string, string>} */ this.Symbols = undefined;\n\n    // created in evaluate() or passed as arg here\n    /** @type {RiScriptVisitor} */this.visitor = undefined;\n\n    /** @type {boolean} */ this.v2Compatible = (options.compatibility === 2);\n\n    const { Constants, tokens } = getTokens(this.v2Compatible);\n\n    ({ Escaped: this.Escaped, Symbols: this.Symbols } = Constants);\n\n    this.pendingGateRe = new RegExp(`${this.Escaped.PENDING_GATE}([0-9]{9,11})`, 'g');\n\n    /** @type {string[]} */ this.textTypes = TextTypes;\n\n    /** @type {Object<string, any>} */ this.RiTa = options.RiTa || {\n      VERSION: 0,\n      randi: (k) => Math.floor(Math.random() * k)\n    }\n\n    /** @type {Object.<string, Function>} */\n    this.transforms = this._createTransforms();\n\n    /** @type {Object.<string, RegExp>} */\n    this.regex = this._createRegexes(tokens);\n\n    /** @type {Lexer} */\n    this.lexer = new Lexer(tokens);\n\n    /** @type {RiScriptParser} */\n    this.parser = new RiScriptParser(tokens, TextTypes);\n  }\n\n  /** @private */\n  lex(opts) {\n    if (!opts.input) throw Error('no input');\n    const lexResult = this.lexer.tokenize(opts.input);\n    if (lexResult.errors.length) {\n      console.error('Input: ' + opts.input + '\\n', lexResult.errors[0].message);\n      throw Error('[LEXING] ' + lexResult.errors[0].message);\n    }\n    if (opts.traceLex) this._printTokens(lexResult.tokens);\n    opts.tokens = lexResult.tokens;\n    // return lexResult;\n  }\n\n  /** @private */\n  parse(opts) {\n    opts.cst = this.parser.parse(opts);\n  }\n\n  /** @private */\n  visit(opts) {\n    // @ts-ignore\n    return this.visitor.start(opts);\n  }\n\n  /**\n   * Evaluates the input script via the RiScript parser\n   * @param {string} script - the script to evaluate\n   * @param {object} [context] - the context (or world-state) to evaluate in\n   * @param {object} [options] - options for the evaluation\n   * @returns {string}\n   */\n  evaluate(script, context, options) {\n    if (typeof script !== 'string') {\n      throw Error('evaluate() expects a string, got ' + typeof script);\n    }\n    if (typeof options !== 'object') {\n      options = {};\n    }\n    options.input = script;\n    options.visitor = new RiScriptVisitor(this, context);\n    return this._evaluate(options);\n  }\n\n  /** @private */\n  lexParseVisit(opts = {}) {\n    this.lex(opts);\n    this.parse(opts);\n    return this.visit(opts);\n  }\n\n  /**\n   * Add a transform function to this instance\n   * @param {string} name - the name of the transform\n   * @param {function} def - the transform function\n   * @returns {RiScript} this instance\n   */\n  addTransform(name, def) {\n    this.transforms[name] = def;\n    return this;\n  }\n\n  /**\n   * Returns the names of all current transforms\n   * @returns {string[]} the names of the transforms\n   */\n  getTransforms() {\n    return Object.keys(this.transforms);\n  }\n\n  /**\n   * Removes a transform function from this instance\n   * @param {string} name of transform to remove\n   * @returns {RiScript} this instance\n   */\n  removeTransform(name) {\n    delete this.transforms[name];\n    return this;\n  }\n\n  ///////////////////////////////////// End API //////////////////////////////////////\n\n  /**\n   * Private version of evaluate taking all arguments in the options object\n   * @param {object} options - options for the evaluation\n   * @param {string} options.input - the script to evaluate\n   * @param {object} options.visitor - the visitor to use for the evaluation\n   * @param {boolean} [options.trace] - whether to trace the evaluation\n   * @param {boolean} [options.onepass] - whether to only do one pass\n   * @param {boolean} [options.silent] - whether to suppress warnings\n   * @returns {string} - the evaluated script's output text\n   * @package\n   */\n  _evaluate(options) {\n\n    const { input, visitor, trace, onepass, silent } = options;\n\n    if (!input) throw Error('no input');\n    if (!visitor) throw Error('no visitor');\n\n    // onepass = true; // TMP\n\n    let last, endingBreak = this.regex.EndingBreak.test(input); // keep\n\n    let expr = this._preParse(input, options);\n    if (!expr) return '';\n\n    if (!options.visitor) throw Error('no visitor');\n    this.visitor = options.visitor;\n    delete options.visitor; // remind me why?\n\n    if (trace) {\n      console.log(`\\nInput:  '${escapeText(input)}' ctx=${visitor.lookupsToString()}`);\n      if (input !== expr) {\n        console.log(`Parsed: '${escapeText(expr)}'`);\n      }\n    }\n\n    for (let i = 1; expr !== last && i <= 10; i++) {\n      last = expr;\n\n      if (trace) console.log('-'.repeat(20)\n        + ' Pass#' + i + ' ' + '-'.repeat(20));\n\n      options.input = expr;\n      expr = this.lexParseVisit(options) ?? '';// do it\n      \n      if (trace) {\n        console.log(`Result(${i}) -> \"` + `${escapeText(expr||'')}\"`\n          + ` ctx=${this.visitor.lookupsToString()}`);\n      }\n\n      // end if no more riscript\n      if (onepass || !this.isParseable(expr)) break;\n    }\n\n    // check for unresolved symbols ([$#]) after removing HTML entities\n    if (!silent && !this.RiTa.SILENT) {\n      if (this.regex.ValidSymbol.test(expr.replace(HtmlEntities, ''))) {\n        console.warn('[WARN] Unresolved symbol(s) in \"'\n          + expr.replace(/\\n/g, '\\\\n') + '\" ');\n      }\n    }\n\n    return this._postParse(expr, options) + (endingBreak ? '\\n' : '');\n  }\n\n  /** @private */\n  _printTokens(tokens) {\n    let s = tokens.reduce((str, t) => {\n      let { name } = t.tokenType;\n      let tag = name;\n      if (tag === 'TEXT') tag = escapeText(t.image, true);\n      if (tag === 'Symbol') tag = 'sym(' + t.image + ')';\n      if (tag === 'TX') tag = 'tx(' + t.image + ')';\n      return str + tag + ', ';\n    }, '')\n      .slice(0, -2);\n    console.log('\\nTokens: [ ' + s + ' ]\\n');//  Context:', this.visitor.lookupsToString());\n  }\n\n  /** @private */\n  _preParse(script, opts) {\n    if (typeof script !== 'string') return '';\n\n    const $ = this.Symbols;\n\n    let input = script;\n    if (!this.v2Compatible) { // handle parenthesized weights\n      input = input.replace(this.regex.ParenthesizedWeights, '^$1^');\n    }\n\n    let matches = input.match(this.regex.MarkdownLinks); // md-links\n    matches && matches.forEach(m => input = input.replace(m, escapeMarkdownLink(m)));\n    input = input.replace(this.regex.MultiLineComments, ''); // multi-line comments\n    input = input.replace(this.regex.SingleLineComments, ''); // single-line comments\n    input = input.replace(this.regex.Continue, ''); // line continuations\n    input = slashEscToEntities(input); // double-backslashed escapes\n\n    let result = '';\n    let lines = input.split(this.regex.LineBreaks);\n    for (let i = 0; i < lines.length; i++) {\n\n      // special-case: handle assignments alone on a line\n      if (this.regex.RawAssign.test(lines[i])) {\n\n        // a very convoluted way of preserving line-breaks inside groups\n        let eqIdx = lines[i].indexOf('=');\n        if (eqIdx < 0) throw Error('invalid state: no assigment: ' + lines[i]);\n        let lhs = lines[i].substring(0, eqIdx),\n          rhs = lines[i].substring(eqIdx + 1);\n        let opens = charCount(rhs, $.OPEN_CHOICE);\n        let closes = charCount(rhs, $.CLOSE_CHOICE);\n        while (opens > closes) {\n          let line = lines[++i];\n          rhs += '\\n' + line;\n          opens += charCount(line, $.OPEN_CHOICE);\n          closes += charCount(line, $.CLOSE_CHOICE);\n        }\n        result += $.OPEN_SILENT + (lhs + '=' + rhs) + $.CLOSE_SILENT;\n\n      } else {\n\n        result += lines[i];\n        if (i < lines.length - 1) result += '\\n';\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Creates a new RiQuery object from the raw query string\n   * @package \n   */\n  createQuery(rawQuery, opts) {\n    return new RiQuery(this, rawQuery, opts);\n  }\n\n  /** @private */\n  _postParse(input, opts) {\n    if (typeof input !== 'string') return '';\n\n    //console.log('_postParse \"' + input + '\"', opts);\n\n    // replace html entities\n    let decoded = decode(input);\n\n    // clean up whitespace, linebreaks\n    let result = decoded\n      .replace(this.regex.Whitespace, ' ')\n      .replace(this.regex.EndingBreak, '');\n\n    // handle unresolved gates\n    let gates = [...result.matchAll(this.pendingGateRe)];\n    //console.log(result, result.length, this.pendingGateRe.toString(), [...result.matchAll(this.pendingGateRe)]);\n    if (opts.trace && gates.length) {\n      console.log('-'.repeat(20) + ' pGates ' + '-'.repeat(20));\n    }\n    this.visitor.order = 0;\n    gates.forEach((g) => {\n      if (!g || !g[0] || !g[1]) throw Error('bad gate: ' + g);\n      let deferredGate = this.visitor.pendingGates[g[1]];\n      if (!deferredGate) throw Error('no deferredGate: ' + g[1]);\n      let { deferredContext, operands, gateText } = deferredGate;\n      if (!operands.length) throw Error('no operands');\n      let reject = this.visitor.choice(deferredContext, { forceReject: true });\n      result = result.replace(g[0], reject);\n      if (opts.trace) console.log('Unresolved gate: \\'' + gateText + '\\' {reject}');\n    });\n\n    if (opts.trace) console.log(`\\nFinal: '${result}'`);\n\n    if (!opts.preserveLookups) {\n      // reset lookups unless preserveLookups=true (for testing only)\n      this.visitor.statics = undefined;\n      this.visitor.dynamics = undefined;\n    }\n\n    return result;\n  }\n\n  /**\n   * Parses a mingo query into JSON format\n   * @package\n   */\n  parseJSOL(text) {\n    const unescapeRegexProperty = (text) => {\n      const RegexEscape = Util.RegexEscape\n      // TODO: why do we need this?\n      let res = text;\n      if (\n        typeof text === 'string' &&\n        text.startsWith(RegexEscape) &&\n        text.endsWith(RegexEscape)\n      ) {\n        let parts = text.split(RegexEscape);\n        if (parts.length !== 4) throw Error('invalid regex in unescape');\n        res = new RegExp(parts[1], parts[2]);\n      }\n      return res;\n    };\n    let escaped = escapeJSONRegex(text)\n      .replace(this.regex.JSOLIdent, '\"$1\":')\n      .replace(/'/g, '\"');\n\n    // console.log(\"escaped: '\"+escaped+\"'\");\n\n    let result = JSON.parse(escaped), urp = unescapeRegexProperty;\n\n    Object.keys(result).forEach((k) => (result[k] = urp(result[k])));\n\n    return result;\n  }\n\n  /**\n   * True if input contains parseable script\n   * @private\n   */\n  isParseable(s) {\n    // conservatively assume non-string/numbers are always parseable\n    // otherwise, if a string or num, test for special chars\n    let result = true;\n    if (typeof s === 'number') {\n      s = s.toString();\n    }\n    if (typeof s === 'string') {\n      result = this.regex.Special.test(s) || s.includes(this.Symbols.PENDING_GATE)\n      // || this.pendingGateRe.test(s);\n    }\n    return result;\n  }\n\n  // ========================= statics ===============================\n\n  /**\n   * Default transform that pluralizes a string (uses RiTa if available for phonemes)\n   * @param {string} s - the string to transform\n   * @param {object} [pluralizer] - custom pluralizer with pluralize() function\n   * @returns {string} the transformed string\n   * @private\n   */\n  static pluralize(s, pluralizer) {\n    if (!pluralizer?.pluralize) {\n      if (!RiScript.RiTaWarnings.plurals && !RiScript.RiTaWarnings.silent) {\n        RiScript.RiTaWarnings.plurals = true;\n        console.warn('[WARN] Install RiTa for proper pluralization');\n      }\n      return s.endsWith('s') ? s : s + 's';\n    }\n    return pluralizer.pluralize(s);\n  }\n\n  /**\n   * Default transform that adds an article (uses RiTa if available for phonemes)\n   * @param {string} s - the string to transform\n   * @param {object} [phonemeAnalyzer] - custom phoneme analyzer with phones() function\n   * @returns {string} the transformed string\n   * @private\n   */\n  static articlize(s, phonemeAnalyzer) {\n    if (!s || !s.length) return '';\n\n    let first = s.split(/\\s+/)[0];\n\n    if (!phonemeAnalyzer?.phones) {\n      if (!RiScript.RiTaWarnings.phones && !RiScript.RiTaWarnings.silent) {\n        console.warn('[WARN] Install RiTa for proper phonemes');\n        RiScript.RiTaWarnings.phones = true;\n      }\n      // first.startsWith('a') ? 'an ' : 'a ') + s;\n      return (/^[aeiou].*/i.test(first) ? 'an ' : 'a ') + s;\n    }\n\n    let phones = phonemeAnalyzer.phones(first, { silent: true });\n\n    // could still be original word if no phones found\n    return ((phones?.length && Vowels.test(phones[0]) ? 'an ' : 'a ') + s);\n  }\n\n  /**\n   * Default transform that uppercases the first character of the string\n   * @param {string} s - the string to transform\n   * @returns {string} the transformed string\n   * @private\n   */\n  static capitalize(s) {\n    return s ? s[0].toUpperCase() + s.substring(1) : '';\n  }\n\n  /**\n   * Default transform that capitalizes the string\n   * @param {string} s - the string to transform\n   * @returns {string} the transformed string\n   * @private\n   */\n  static uppercase(s) {\n    return s ? s.toUpperCase() : '';\n  }\n\n  /**\n   * Default transform that wraps the string in (smart) quotes.\n   * @param {string} s - the string to transform\n   * @returns {string} the transformed string\n   * @private\n   */\n  static quotify(s) {\n    return '&#8220;' + (s || '') + '&#8221;';\n  }\n\n  /**\n   * Default no-op transform\n   * @param {string} s - the string to transform\n   * @returns {string} the transformed string\n   * @private\n   */\n  static identity(s) {\n    return s;\n  }\n\n    // ========================= helpers ===============================\n\n  /** @private */\n  _createRegexes(tokens) {\n\n    const Esc = this.Escaped;\n    const open = Esc.OPEN_CHOICE;\n    const close = Esc.CLOSE_CHOICE;\n    const anysym = Esc.STATIC + Esc.DYNAMIC;\n\n    return {\n      LineBreaks: /\\r?\\n/,\n      EndingBreak: /\\r?\\n$/,\n      NonGateAtSigns: /([^}])@(?!{)/,\n      AnySymbol: new RegExp(`[${anysym}]`),\n      ParenthesizedWeights: /\\(\\s*(\\d+)\\s*\\)/g, // TODO: change for negative weights\n      MultiLineComments: /\\/\\*[^]*?(\\r?\\n)?\\//g,\n      SingleLineComments: /\\/\\/[^\\n]+(\\r?\\n|$)/g,\n      MarkdownLinks: /\\[([^\\]]+)\\]\\(([^)\"]+)(?: \\\"([^\\\"]+)\\\")?\\)/g,\n      RawAssign: new RegExp(`^[${anysym}][A-Za-z_0-9][A-Za-z_0-9]*\\\\s*=`),\n      JSOLIdent: new RegExp(`([${anysym}]?[A-Za-z_0-9][A-Za-z_0-9]*)\\\\s*:`, 'g'),\n      ChoiceWrap: new RegExp('^' + open + '[^' + open + close + ']*' + close + '$'),\n      ValidSymbol: new RegExp('(' + Esc.DYNAMIC + '|' + Esc.STATIC + '[A-Za-z_0-9])[A-Za-z_0-9]*'),\n      Entity: tokens.filter(t => t.name === 'Entity')[0].PATTERN,\n      StaticSymbol: new RegExp(Esc.STATIC + '[A-Za-z_0-9][A-Za-z_0-9]*'),\n      Special: new RegExp(`[${Esc.SPECIAL.replace('&', '')}]`),\n      Continue: new RegExp(Esc.CONTINUATION + '\\\\r?\\\\n', 'g'),\n      Whitespace: /[\\u00a0\\u2000-\\u200b\\u2028-\\u2029\\u3000]+/g,\n    };\n  }\n\n  /** @private */\n  _createTransforms() {\n    let transforms = {\n      quotify: (w) => RiScript.quotify(w),\n      pluralize: (w) => RiScript.pluralize(w, this.RiTa),\n      articlize: (w) => RiScript.articlize(w, this.RiTa),\n      capitalize: (w) => RiScript.capitalize(w),\n      uppercase: (w) => RiScript.uppercase(w),\n      norepeat: (w) => RiScript.identity(w),\n    };\n\n    // aliases\n    transforms.art = transforms.articlize;\n    transforms.nr = transforms.norepeat;\n    transforms.cap = transforms.capitalize;\n    transforms.uc = transforms.uppercase;\n    transforms.qq = transforms.quotify;\n    transforms.s = transforms.pluralize;\n    transforms.ucf = transforms.capitalize; // @dep\n\n    return transforms;\n  }\n}\n\nfunction charCount(str, c) {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === c) count++;\n  }\n  return count;\n}\n\n// Class ref hacks for testing\nRiScript.Visitor = RiScriptVisitor;\nRiScript.Util = Util;\n\nexport { RiScript };","// @ts-nocheck\nimport { CstParser } from \"chevrotain\"\n\n/**\n * RiScriptParser\n * @class\n * @memberof module:riscript\n */\nclass RiScriptParser extends CstParser {\n\n  constructor(allTokens, textTypes) {\n    super(allTokens, { nodeLocationTracking: \"full\" });\n    this.atomTypes = ['silent', 'assign', 'symbol', 'choice', 'pgate', 'text', 'entity'];\n    this.textTypes = textTypes; // defined in tokens.js\n    this.buildRules();\n  }\n\n  parse(opts) {\n    this.input = opts.tokens; // superclass member (dont change)\n\n    let cst = this.script();\n    if (this.errors.length > 0) throw Error\n      (\"[PARSING]\\n\" + this.errors[0].message);\n    return cst;\n  }\n\n  /*\n    Specification:\n      script: expr+\n      expr: atom+\n      atom: (choice | symbol | text | silent | entity | pgate | assign)\n      wexpr: (expr | Weight)*\n      symbol: Symbol transform*\n      choice: [ gate? orExpr elseExpr? ] transform*\n      assign: Symbol EQ expr\n      silent: { gate? (symbol | assign) }\n      orExpr: wexpr (OR wexpr)*\n      elseExpr: ELSE orExpr\n      pgate: PGate\n      entity: Entity\n      gate: Mingo\n      text: Raw | STAT | AMP \n  */\n  buildRules() {\n\n    const $ = this, Tokens = this.tokensMap;\n\n    $.RULE(\"script\", () => {\n      $.MANY(() => $.SUBRULE($.expr));\n    });\n\n    $.RULE(\"expr\", () => {\n      $.AT_LEAST_ONE(() => $.SUBRULE($.atom));\n    });\n\n    $.RULE(\"atom\", () => {\n      $.OR(this.atomTypes.map(t => ({ ALT: () => $.SUBRULE($[t]) })));\n    });\n\n    $.RULE(\"wexpr\", () => {\n      $.MANY(() => {\n        $.OR([\n          { ALT: () => $.SUBRULE($.expr) },\n          { ALT: () => $.CONSUME(Tokens.Weight) },\n        ])\n      });\n    });\n\n    $.RULE(\"symbol\", () => {\n      $.CONSUME(Tokens.Symbol);\n      $.MANY(() => $.CONSUME(Tokens.Transform));\n    });\n\n    // choice: (LP (wexpr OR)* wexpr RP) transform*;\n    $.RULE(\"choice\", () => {\n      $.CONSUME(Tokens.OC)\n      $.OPTION1(() => $.SUBRULE($.gate));\n      $.SUBRULE($.orExpr)\n      $.OPTION2(() => {\n        $.SUBRULE2($.elseExpr)\n      });\n      $.CONSUME(Tokens.CC);\n      $.MANY(() => $.CONSUME(Tokens.Transform));\n    });\n\n    $.RULE(\"assign\", () => {\n      $.CONSUME(Tokens.Symbol);\n      $.CONSUME(Tokens.EQ);\n      $.SUBRULE($.expr);\n    });\n\n    $.RULE(\"silent\", () => {\n      $.CONSUME(Tokens.OS);\n      $.OPTION1(() => $.SUBRULE($.gate));\n      $.CONSUME(Tokens.Symbol);\n      $.OPTION2(() => {\n        $.CONSUME(Tokens.EQ);\n        $.SUBRULE($.expr);\n      });\n      $.CONSUME(Tokens.CS);\n    });\n\n    $.RULE(\"orExpr\", () => {\n      $.MANY_SEP({\n        SEP: Tokens.OR,\n        DEF: () => $.SUBRULE($.wexpr)\n      });\n    });\n\n    $.RULE(\"elseExpr\", () => {\n      $.CONSUME(Tokens.ELSE);\n      $.SUBRULE($.orExpr);\n    });\n\n    $.RULE(\"pgate\", () => {\n      $.CONSUME(Tokens.PendingGate);\n      //$.MANY(() => $.CONSUME(Tokens.Transform));\n    });\n\n    $.RULE(\"entity\", () => {\n      $.CONSUME(Tokens.Entity);\n    });\n\n    $.RULE(\"gate\", () => {\n      $.MANY(() => $.CONSUME(Tokens.Gate));\n    });\n\n    $.RULE(\"text\", () => {\n      $.OR(this.textTypes.map(t => ({ ALT: () => $.CONSUME(Tokens[t]) })));\n    });\n\n    this.performSelfAnalysis(); // keep\n  }\n}\n\nexport { RiScriptParser };","/**\n * @memberof module:riscript\n */\nclass Util {\n\n  ///////////////////////// CONSTANTS /////////////////////////\n\n\n  /**\n   * @static\n   * @memberof Util\n   * @package\n   */\n  static RegexEscape = '_RE_';\n\n  ///////////////////////// FUNCTIONS /////////////////////////\n\n  static formatAny(o) {\n    if (typeof o === 'string') return `'${o}'`;\n    else if (typeof o === 'number') return o;\n    if (typeof o === 'function') throw Error('unexpected function');\n    return JSON.stringify(o).replace(/\"/g, '');\n  }\n\n  static transformNames(txs) {\n    return txs && txs.length\n      ? txs.map((tx) => tx.image.replace(/(^\\.|\\(\\)$)/g, ''), [])\n      : [];\n  }\n\n  static escapeText(s, quotify) {\n    if (typeof s !== 'string') return Util.formatAny(s);\n    let t = s.replace(/\\r?\\n/g, '\\\\n');\n    return quotify || !t.length ? \"'\" + t + \"'\" : t;\n  }\n\n  static stringHash(s) { // for testing\n    let chr,\n      hash = 0;\n    for (let i = 0; i < s.length; i++) {\n      chr = s.charCodeAt(i);\n      hash = (hash << 5) - hash + chr;\n      hash |= 0; // Convert to 32bit integer\n    }\n    let strHash = hash.toString().padStart(9, '0');\n    return hash < 0 ? strHash.replace('-', '0') : strHash;\n  }\n\n  static escapeMarkdownLink(txt) {\n    let result = txt;\n    let lookups = { '[': '&lsqb;', ']': '&rsqb;', '(': '&lpar;', ')': '&rpar;', '/': '&sol;' };\n    Object.entries(lookups).forEach(([k, v]) => result = result.replace(new RegExp(`\\\\${k}`, 'g'), v));\n    return result;\n  }\n\n  static slashEscToEntities(s) {\n    s = Util.replaceAll(s, '\\\\(', '&lpar;');\n    s = Util.replaceAll(s, '\\\\)', '&rpar;');\n    s = Util.replaceAll(s, '\\\\[', '&lsqb;');\n    s = Util.replaceAll(s, '\\\\]', '&rsqb;');\n    s = Util.replaceAll(s, '\\\\{', '&lcqb;');\n    s = Util.replaceAll(s, '\\\\}', '&rcqb;');\n    s = Util.replaceAll(s, '\\\\@', '&commat;');\n    s = Util.replaceAll(s, '\\\\#', '&num;');\n    s = Util.replaceAll(s, '\\\\|', ' &vert');\n    s = Util.replaceAll(s, '\\\\=', ' &equals');\n    return s;\n  }\n\n  static escapeJSONRegex(text) {\n    return text.replace(\n      /\\/([^/]+?)\\/([igmsuy]*)/g,\n      `\"${Util.RegexEscape}$1${Util.RegexEscape}$2${Util.RegexEscape}\"`\n    );\n  }\n\n  static escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  }\n\n  static replaceAll(str, match, replacement) {\n    return str.replace(new RegExp(Util.escapeRegExp(match), 'g'), () => replacement);\n  }\n\n}\n\nexport { Util };","/** @module riscript */\n\nimport { Util } from './util.js';\n\nconst { escapeText, stringHash, formatAny, transformNames } = Util;\n\n/**\n * @class\n * @memberof module:riscript\n */\nclass BaseVisitor {\n  constructor(riScript) {\n    /**@type {string}*/this.input = '';\n    /**@type {boolean}*/this.nowarn = false;\n    /**@type {boolean}*/this.tracePath = true;\n    /**@type {object}*/this.scripting = riScript;\n    /**@type {boolean}*/this.warnOnInvalidGates = false;\n    /**@type {number}*/this.maxRecursionDepth = 10;\n  }\n\n  textFromCstNode(node) {\n    if (Array.isArray(node)) node = node[0];\n    return this.input.substring(\n      node.location.startOffset,\n      node.location.endOffset + 1\n    );\n  }\n\n  isCstNode(o) {\n    if (Array.isArray(o)) o = o[0];\n    return (typeof o === 'object' && ('accept' in o\n      || ('name' in o && 'location' in o && 'children' in o)));\n  }\n\n  visit(cstNode, options) {\n    if (Array.isArray(cstNode)) {\n      cstNode = cstNode[0];\n    }\n    if (typeof cstNode === 'undefined') {\n      return undefined;\n    }\n    if (!this.isCstNode(cstNode)) {\n      throw Error('Non-cstNode passed to visit: ' + JSON.stringify(cstNode));\n    }\n    this.nodeText = this.textFromCstNode(cstNode); // remove\n\n    const name = cstNode.name;\n    if (typeof this[name] !== 'function') {\n      throw Error('BaseVisitor.visit: expecting function for this[' +\n        `${name}], found ${typeof this[name]}: ${JSON.stringify(this[name])}`);\n    }\n    return this[name](cstNode.children, options);\n  }\n\n  validateVisitor() { /* no-op */ }\n}\n\n/**\n * @class\n * @memberof module:riscript\n */\nclass RiScriptVisitor extends BaseVisitor {\n  constructor(riScript, context = {}) {\n    super(riScript);\n\n    this.order = 0;\n    this.trace = 0;\n    this.indent = 0;\n    this.choices = {};\n    this.context = context;\n    this.isNoRepeat = false;\n\n    this.Symbols = this.scripting.Symbols;\n    this.Escaped = this.scripting.Escaped;\n\n    // lookups\n    this.statics = {}; // store static symbols as values, set once and re-used\n    this.dynamics = {}; // store dynamic symbols as functions to be re-evaluated each time\n    this.pendingGates = {}; // store gates for which operands are not resolved\n\n    this.validateVisitor(); // keep\n  }\n\n  start(opts = {}) {\n\n    this.input = opts.input;\n    this.trace = opts.trace;\n    this.nowarn = opts.silent;\n    this.traceTx = opts.traceTx;\n    if (!opts.cst) throw Error('no cst');\n    return super.visit(opts.cst);\n  }\n\n  script(ctx) {\n    this.order = this.indent = 0;\n    if (Object.keys(ctx).length !== 1) throw Error('script: invalid expr');\n    let count = ctx.expr[0].children.atom.length;\n    this.print('script', `'${escapeText(this.input)}' :: ${count} atom(s)`);\n    if (!count) return '';\n    this.indent++;\n    let value = this.visit(ctx.expr);\n    this.indent--;\n    this.print('/script');\n    return value;\n  }\n\n  expr(ctx) {\n    // this.print('expr', ctx);\n    const types = Object.keys(ctx);\n    if (types.length !== 1) throw Error('invalid expr: ' + types.length);\n    const exprs = ctx.atom.map((c) => this.visit(c)); // collect each atom\n\n    if (exprs.length === 1) return exprs[0];\n\n    // handle special cases of the form: \"not [quite|] far enough\"\n    for (let i = 1; i < exprs.length - 1; i++) {\n      if (exprs[i].length === 0 &&\n        exprs[i - 1].endsWith(' ') &&\n        exprs[i + 1].startsWith(' ')) {\n        exprs[i + 1] = exprs[i + 1].substring(1);\n      }\n    }\n    return exprs.join('');\n  }\n\n  atom(ctx) {\n    let result;\n    const types = Object.keys(ctx);\n    if (types.length !== 1) throw Error('invalid atom: ' + types);\n    this.scripting.parser.atomTypes.forEach((type) => {\n      if (ctx[type]) {\n        if (ctx[type].length !== 1) {\n          throw Error(type + ': bad length -> ' + ctx[type].length);\n        }\n        result = this.visit(ctx[type][0]);\n        // pending function, call it\n        if (typeof result === 'function') {\n          result = result.call();\n        }\n      }\n    });\n    return result;\n  }\n\n  silent(ctx) {\n    this.print('silent', this.nodeText);\n    this.indent++;\n    if (ctx.EQ) {\n      this.assign(ctx, { silent: true });\n    } else {\n      this.symbol(ctx, { silent: true });\n    }\n    this.indent--;\n    this.print('/silent', 'statics=' + formatAny(this.statics));\n\n    return '';\n  }\n\n  assign(ctx, opts) {\n\n    const sym = ctx.Symbol[0].image;\n    const original = this.nodeText;\n    const ident = sym.replace(this.scripting.regex.AnySymbol, '');\n    const isStatic = sym.startsWith(this.Symbols.STATIC);\n    const isSilent = opts?.silent;\n\n    let info = `${original} ${isStatic && isSilent ? '{#static,silent}' :\n      (isStatic ? '{#static}' : '') + (isSilent ? '{silent}' : '')}`;\n    this.print('assign', info);\n\n    let value;\n    if (isStatic) { // static: store as value, set once and re-use\n\n      if (ident in this.statics && !this.scripting.isParseable(this.statics[ident])) {\n        value = this.statics[ident];\n        info = `${sym} = ${formatAny(value)} {#resolved}`;\n      }\n      else {\n        // TODO: move indent++/-- to visit() ?\n        this.indent++;\n        value = this.visit(ctx.expr); // visit the right-hand side\n        this.indent--;\n\n        this.statics[ident] = value;  // store in lookup table, resolved or not\n\n        if (typeof value === 'string' && this.scripting.isParseable(value)) {\n          value = this.inlineStaticAssign(ident, ctx.Transform, value);\n        }\n        info = `${sym} = ${formatAny(value)}`;\n      }\n      this.print('/assign', info);\n    } else {\n      const $ = this;\n\n      // dynamic: store as func to be resolved later, perhaps many times\n      // OPT: check if parseable. if not, remove the function and use the value directly?\n      this.indent++;\n      value = () => $.visit(ctx.expr); // the right-hand side\n      this.indent--;\n\n      // NOTE: this function may contain a choice, which needs to be handled\n      // when called from a symbol with a norepeat transform (??) TODO: test\n\n      this.dynamics[ident] = value; // store in lookup table\n      this.print('/assign', `${sym} =  <f*:pending>`);\n    }\n\n    return value;\n  } // end assign\n\n  symbol(ctx, opts) {\n    if (ctx.Symbol.length !== 1) throw Error('[1] invalid symbol');\n\n    const isSilent = opts?.silent;\n    const original = this.nodeText;\n    const sym = ctx.Symbol[0].image.replace(/\\(\\)$/, '');\n    const ident = sym.replace(this.scripting.regex.AnySymbol, '');\n    this.isNoRepeat = this.hasNoRepeat(ctx.Transform);\n\n    this.print('symbol', `${original} ${isSilent ? ' {silent}' : ''}`);\n\n    // lookup: result is either a value, a function, or undef\n    let { result, isStatic, isUser, resolved } = this.checkContext(ident);\n\n    if (!isStatic && this.scripting.regex.StaticSymbol.test(sym)) {\n      if (!this.scripting.regex.Entity.test(sym)) {\n        throw Error(`Attempt to refer to dynamic symbol '${ident}' as` +\n          ` ${this.Symbols.STATIC}${ident}, did you mean $${ident}?`);\n      }\n    }\n\n    // if we have a function, call it here (potentially many times)\n    for (let i = 0; typeof result === 'function'; i++) {\n      result = result.call();\n      resolved = !this.scripting.isParseable(result);\n      if (i === this.maxRecursionDepth) throw Error('Max recursion depth reached');\n    }\n\n    // check for norepeat on a non-dynamic symbol and throw if found\n    if (this.isNoRepeat && (isStatic || isUser)) {\n      this.isNoRepeat = false;\n      const msg = 'Attempt to call norepeat() on ' + (isStatic\n        ? \"static symbol '\" + sym + \"'. Did you mean to use '\" +\n        this.Symbols.DYNAMIC + ident + \"' ?\"\n        : \"non-dynamic symbol '\" + ident + \"'. Did you mean to define '\" +\n        this.Symbols.DYNAMIC + ident + \"' in riscript?\");\n      throw Error(msg);\n    }\n\n    // nothing found thus far, so defer for now\n    if (typeof result === 'undefined') {\n      this.print('/symbol', sym + \" -> '\" + original + \"' ctx=\" +\n        this.lookupsToString(), '[deferred]', opts?.silent ? '{silent}' : '');\n      return original;\n    }\n\n    let info = opts?.trace ? `${original.replace(/\\(\\)$/, '')} -> ${formatAny(result)}`\n      + (opts?.silent ? ' {silent}' : '') : null; // for logging\n\n    // also defer if we still have unresolved script\n    if (typeof result === 'string' && !resolved) {\n      if (isStatic) {\n        result = this.inlineStaticAssign(ident, ctx.Transform, result);\n        this.print('/symbol', `${original} -> ${result}`);// :: pending.add(${ident})`);\n      } else {\n        if (ctx.Transform) result = this.restoreTransforms(result, ctx.Transform);\n        this.print('/symbol', info);\n      }\n      return result;\n    }\n\n    // store untransformed result in static context\n    if (isStatic) this.statics[ident] = result; // ADDED 8/18/23, FIXED 10/8/23\n\n    // finally, apply any transforms\n    if (ctx.Transform) {\n      result = this.applyTransforms(result, ctx.Transform);\n      info += \"-> '\" + result + \"'\";\n      if (this.isNoRepeat) info += ' (norepeat)';\n    }\n    else if (result.length === 0 && sym.length === 1) {\n      // this is a raw $, without transform, keep it DCH: 1/21/24\n      result = sym;\n      info = '** $ **';\n    }\n\n    this.print('/symbol', info);\n    this.isNoRepeat = false; // reset\n\n    return result;\n  } // end symbol\n\n  choice(ctx, opts) {\n    const $ = this.Symbols;\n    const original = this.nodeText;\n    const choiceKey = stringHash(original + ' #' + this.choiceId(ctx));\n\n    let gateText, gateResult, hasTransforms = ctx.Transform;\n\n    if (!this.isNoRepeat && this.hasNoRepeat(ctx.Transform)) {\n      throw Error('noRepeat() not allowed on choice '\n        + '(use a $variable instead): ' + original);\n    }\n\n    this.print('choice', original);\n\n    let decision = 'accept';\n    if (opts?.forceReject) {\n      decision = 'reject';\n    } else {\n      // TODO: make function -> handleGate(ctx) returns \n      //    { decision: [accept|reject] } or { decision: 'defer', pgateValue }\n      let gateCtx = ctx?.gate?.[0]?.children?.Gate;\n      if (gateCtx) {\n        // do we have a gate?\n        gateText = gateCtx[0].image;\n        this.indent++;\n        gateResult = this.visit(ctx.gate);\n        this.indent--;\n        decision = gateResult.decision;\n        let ginfo = `${gateText} -> ${(decision !== 'defer' ? decision.toUpperCase()\n          : `DEFER ${$.PENDING_GATE}${choiceKey}`)}  ${this.lookupsToString()}`;\n        this.print('gate', ginfo);\n      }\n\n      if (gateResult && gateResult.decision === 'defer') {\n        this.pendingGates[choiceKey] = {\n          gateText,\n          deferredContext: ctx,\n          operands: gateResult.operands\n        };\n        return `${$.PENDING_GATE}${choiceKey}`; // gate defers\n      }\n    }\n\n    let orExpr = ctx?.orExpr[0];\n    if (decision === 'reject') {\n      if (!('elseExpr' in ctx)) return ''; // rejected without else\n      orExpr = ctx.elseExpr[0].children.orExpr[0];\n    }\n\n    const options = this.parseOptions(orExpr); // get options\n    if (!options) throw Error('No options in choice: ' + original);\n\n    let value = null;\n    const excluded = [];\n    let restored = false;\n    while (value === null) {\n      value = this.choose(options, excluded);\n\n      // while we have a cstNode, visit it\n      for (let i = 0; this.isCstNode(value); i++) {\n        this.indent++;\n        value = this.visit(value); // visit the node\n        this.indent--;\n        if (i === this.maxRecursionDepth) throw Error('Max recursion depth reached');\n      }\n\n      if (typeof value === 'string') {\n        value = value.trim();\n      }\n      else if (typeof value !== 'number') { // some type of complex object\n        if (ctx.Transform) value = this.applyTransforms(value, ctx.Transform);\n        hasTransforms = false; // applied the transform so don't do it again later;\n      }\n\n      // if we still have script, defer until its resolved\n      if (this.scripting.isParseable(value)) {\n        if (ctx.Transform) value = this.restoreTransforms(value, ctx.Transform);\n        restored = true;\n        break;\n      }\n\n      // apply any remaining transforms\n      if (hasTransforms) value = this.applyTransforms(value, ctx.Transform);\n\n      // we have 'norepeat' but value was already used, try again\n      if (this.isNoRepeat && value === this.choices[choiceKey]) {\n        this.print('choice-reject', value + ' [norepeat]');\n        excluded.push(value);\n        value = null;\n        continue;\n      }\n    }\n\n    if (!restored) this.choices[choiceKey] = value; // put in choice cache\n    this.print('choice/', original + ' -> \\'' + value + '\\'');\n\n    return value;\n  } // end choice\n\n  choose(options, excludes = []) {\n    if (!options || !options.length) {\n      throw Error('Invalid choice: no options');\n    }\n    const valid = options.filter(x => !excludes.includes(x));\n    if (!valid.length) {\n      throw Error('Invalid choice: no valid options');\n    }\n    const index = this.scripting.RiTa.randi(valid.length);\n    let value = valid[index];\n    return value;\n  }\n\n  text(ctx) {\n    if (Object.keys(ctx).length !== 1) throw Error('[2] invalid text');\n    const type = this.scripting.textTypes.filter(t => ctx[t]);\n    const image = ctx[type][0].image; // any of riscript.textTypes\n    this.print('text/', escapeText(\"'\" + image + \"'\"));\n    return image;\n  }\n\n  entity(ctx) {\n    return this.nodeText;\n  }\n\n  gate(ctx) {\n    // returns { decision: [accept|reject] } or { decision: 'defer', operands: [] }\n\n    if (ctx.Gate.length !== 1) throw Error('Invalid gate: ' + ctx.Gate);\n\n    let raw = ctx.Gate[0].image, mingoQuery;\n    if (raw.startsWith(this.Symbols.OPEN_GATE)) {\n      raw = raw.substring(1);\n    }\n    try {\n      mingoQuery = this.scripting.createQuery(raw);\n    } catch (e) {\n      if (!this.warnOnInvalidGates) {\n        throw Error(`Invalid gate[2]: \"@${raw}\"\\n\\nRootCause -> ${e}`);\n      }\n      if (!this.scripting.RiTa.SILENT && !this.nowarn) {\n        console.warn(`[WARN] Ignoring invalid gate: @${raw}@\\n`, e);\n      }\n      return { decision: 'accept' };\n    }\n\n    const resolvedOps = {};\n    const unresolvedOps = [];\n    const operands = mingoQuery.operands();\n    operands.forEach((sym) => {\n      let { result, resolved, isStatic, isUser } = this.checkContext(sym);\n\n      for (let i = 0; typeof result === 'function'; i++) {\n        result = result.call(); // call it\n        resolved = !this.scripting.isParseable(result);\n        if (i === this.maxRecursionDepth) throw Error('Max recursion depth reached');\n      }\n\n      if (typeof result === 'undefined' || !resolved) {\n        unresolvedOps.push(sym);\n      } else {\n        // add to appropriate context\n        if (isStatic) {\n          this.statics[sym] = result;\n        } else if (isUser) {\n          this.context[sym] = result;\n        } else {\n          this.dynamics[sym] = result;\n        }\n        // store resolved result\n        resolvedOps[sym] = result;\n      }\n    });\n\n    if (Object.keys(resolvedOps).length + unresolvedOps.length !== operands.length) {\n      throw Error('invalid operands');\n    }\n\n    // if we have unresolved operands, return them (and defer)\n    if (unresolvedOps.length) {\n      return { decision: 'defer', operands: unresolvedOps };\n    }\n\n    let result = mingoQuery.test(resolvedOps); // do test\n    if (!result && this.castValues(resolvedOps)) {\n      result = mingoQuery.test(resolvedOps); // redo test after casting\n    }\n\n    return { decision: result ? 'accept' : 'reject' };\n  }\n\n  pgate(ctx) {\n    this.print('pgate', this.nodeText);\n\n    const original = this.nodeText;\n    const ident = original.replace(this.Symbols.PENDING_GATE, '');\n    const lookup = this.pendingGates[ident];\n\n    if (!lookup) {\n      throw Error('no pending gate=\"' + original + '\" pgates=' +\n        JSON.stringify(Object.keys(this.pendingGates)));\n    }\n\n    const stillUnresolved = lookup.operands.some((o) => {\n      let { result, resolved } = this.checkContext(o);\n      if (typeof result === 'function') {\n        // while {} ?\n        // let tracing = this.trace;\n        // this.trace = false; // disable tracing\n        result = result.call(); // call it\n        //this.trace = tracing;\n        resolved = !this.scripting.isParseable(result);\n      }\n      return typeof result === 'undefined' || !resolved;\n    });\n\n    if (stillUnresolved) return original; // still deferred\n\n    return this.choice(lookup.deferredContext); // execute the gate\n  }\n\n  else(ctx) {\n    // this.print('else', this.nodeText);\n    return this.visit(ctx.expr).trim();\n  }\n\n\n  // Helpers ================================================\n\n  hasNoRepeat(tfs) {\n    const transforms = transformNames(tfs);\n    if (transforms.length) {\n      return transforms.includes('nr') || transforms.includes('norepeat');\n    }\n    return false;\n  }\n\n  checkContext(ident, opts = {}) {\n    let isStatic = false;\n    let isUser = false;\n    let result;\n\n    // empty symbol, just return\n    if (ident.length === 0) { \n      return { result: '', resolved: true, isStatic, isUser };\n    }\n\n    // check for dynamic symbol: $var\n    result = this.dynamics[ident];\n    if (typeof result === 'undefined') {\n      // no dynamic, check for static symbol: #var\n      result = this.statics[ident];\n      if (typeof result !== 'undefined') {\n        isStatic = true; // found static\n      }\n    }\n\n    if (typeof result === 'undefined') {\n      // no static, check for user-defined symbol: context[var]\n      result = this.context[ident];\n      if (typeof result !== 'undefined') {\n        isUser = true; // found user symbol\n      } \n    }\n\n    if (typeof result === 'undefined') {\n      // last option: check for bare transform: $var()\n      result = this.scripting.transforms[ident];\n    }\n\n    // do we have more script to deal with ?\n    const resolved = !this.scripting.isParseable(result);\n\n    return { result, isStatic, isUser, resolved }; // TODO: replace with 'type'\n  }\n\n  inlineStaticAssign(ident, tfs, result) {\n    const $ = this.Symbols;\n    const lhs = $.STATIC + ident;\n    const rhs = result;\n    let stmt = $.OPEN_CHOICE + (lhs + '=' + rhs) + $.CLOSE_CHOICE;\n    result = this.restoreTransforms(stmt, tfs);\n    return result;\n  }\n\n  choiceId(ctx) {\n    if (!ctx.OC || !ctx.OC.length) throw Error('invalid choice');\n    return ctx.OC[0].startOffset + '.' + ctx.OC[0].endOffset;\n  }\n\n  parseOptions(ctx) {\n    const options = [];\n    if (ctx && ctx?.children?.wexpr) {\n      const wexprs = ctx.children.wexpr;\n      for (let i = 0; i < wexprs.length; i++) {\n        const wexpr = wexprs[i];\n        const expr = wexpr.children.expr;\n        if (expr && expr.length != 1) { throw Error('invalid choice-expr: ' + expr.length); }\n\n        const weight = wexpr.children.Weight;\n        if (weight) {\n          if (weight.length != 1) { throw Error('invalid weight: ' + weight.length); }\n          let mult = 1;\n          try {\n            mult = parseInt(\n              this.Symbols.CLOSE_WEIGHT.length\n                ? weight[0].image.trim().slice(1, -1)\n                : weight[0].image.trim().slice(1)\n            );\n          } catch (e) {\n            console.log('EX: ' + mult);\n          }\n          Array.from({ length: mult }, () => options.push(expr));\n        } else {\n          options.push(expr || '');\n        }\n      }\n    }\n    return options;\n  }\n\n  applyTransforms(value, txs) {\n    this.indent++;\n    if (this.traceTx) { console.log('applyTransforms', this.formatTxs(...arguments)); }\n    for (let i = 0; i < txs.length; i++) {\n      value = this.applyTransform(value, txs[i]);\n    }\n    this.indent--;\n    return value;\n  }\n\n  applyTransform(target, transform) {\n\n    const image = transform.image;\n    const raw = target + image;\n    const original = formatAny(target) + image;\n    const tx = image.substring(1).replace(/\\(\\)$/, '');\n    const RiTa = this.scripting.RiTa;\n\n    let result;\n\n    // function in dynamics\n    if (typeof this.dynamics[tx] === 'function') {\n      result = this.dynamics[tx].bind(this.context)(target);\n    }\n    // function in statics\n    else if (typeof this.statics[tx] === 'function') {\n      result = this.statics[tx].call(this.context, target);\n    }\n    // function in context\n    else if (typeof this.context[tx] === 'function') {\n      result = this.context[tx].call(this.context, target);\n    }\n    // function in transforms\n    else if (typeof this.scripting.transforms[tx] === 'function') {\n      result = this.scripting.transforms[tx].call(this.context, target);\n    }\n    // member functions (usually on String)\n    else if (typeof target[tx] === 'function') {\n      result = target[tx]();// .call() ?\n    } else {\n      // check for property\n      if (target.hasOwnProperty(tx)) {\n        result = target[tx];\n      } else {\n        if (!RiTa.SILENT && !this.silent) {\n          console.warn('[WARN] Unresolved transform: ' + raw);\n        }\n\n        /* Replace transform parens so as not to trigger\n           RiScript.isParseable (for example, in v2) 0 */\n        result = raw.replace(/\\(\\)$/, '&lpar;&rpar;');\n      }\n    }\n\n    this.print('transform/', `${original} -> '${result}'`);\n\n    return result;\n  }\n\n  // value is not yet resolved, so store with transform for later\n  restoreTransforms(value, txs) {\n    if (typeof value === 'string') {\n      const choiceRE = new RegExp('^' + this.Escaped.OPEN_CHOICE + '.*' + this.Escaped.CLOSE_CHOICE + '$');\n      const symbolRE = new RegExp(`(${this.Escaped.DYNAMIC}|${this.Escaped.STATIC}[A-Za-z_0-9])[A-Za-z_0-9]*`);\n      if (!choiceRE.test(value) && !symbolRE.test(value)) {\n        // wrap in choice to preserve\n        value = this.Symbols.OPEN_CHOICE + value + this.Symbols.CLOSE_CHOICE;\n      }\n      if (txs) {\n        txs.forEach((tx) => (value += tx.image)); // append transform strings\n      }\n      if (this.traceTx) console.log('restoreTransforms:', value);\n    }\n    return value;\n  }\n\n  castValues(obj) {\n    let madeCast = false;\n    Object.entries(obj).forEach(([k, v]) => {\n      const num = parseFloat(v);\n      if (!isNaN(num)) {\n        madeCast = true;\n        obj[k] = num; // update object with casted value\n      }\n    });\n    return madeCast;\n  }\n\n  contextIsResolved(table) {\n    let allResolved = true;\n    Object.entries(table).forEach(([key, val]) => {\n      if (!this.scripting.isParseable(val)) {\n        allResolved = false;\n      }\n    });\n    return allResolved;\n  }\n\n  lookupsToString() {\n    const dyns = {}, stats = {};\n    Object.entries(this.dynamics || {}).forEach(([k, v]) => (dyns[`$${k}`] = v));\n    Object.entries(this.statics || {}).forEach(([k, v]) => (stats[`#${k}`] = v));\n    return JSON.stringify({ ...this.context, ...stats, ...dyns }, (k, v) =>\n      typeof v === 'function' ? '<f*:pending>' : v).replace(/\"/g, '');\n  }\n\n  formatTxs(value, txs) {\n    return value + txs.map((tx) => tx.image.replace(/()/, '') + '()').join('');\n  }\n\n  print(s, ...args) {\n    if (this.trace) {\n      let indentStr = '  '.repeat(this.indent);\n      let msg = `${indentStr}<${s}>${s.startsWith('/') ? '' : ' '}`;\n      if (++this.order < 10) msg = ' ' + msg;\n      console.log(this.order, msg, ...args);\n    }\n  }\n}\n\nexport { RiScriptVisitor };","/**\n * @memberof module:riscript\n */\nimport { createToken } from \"chevrotain\"\n\nfunction getTokens(v2Compatible) {\n\n  let Symbols = {\n    OR: '|',\n    ELSE: '||',\n    DYNAMIC: '$',\n    STATIC: '#',\n    ENTITY: '&',\n    OPEN_GATE: '@',\n    PENDING_GATE: '@@',\n    OPEN_SILENT: '{',\n    CLOSE_SILENT: '}',\n  };\n\n  let v2Symbols = {\n    OPEN_CHOICE: '(',\n    CLOSE_CHOICE: ')',\n    OPEN_WEIGHT: '[',\n    CLOSE_WEIGHT: ']',\n    CONTINUATION: '\\\\',\n  };\n\n  let v3Symbols = {\n    OPEN_CHOICE: '[',\n    CLOSE_CHOICE: ']',\n    OPEN_WEIGHT: '^', // also allows (int), eg. (3)\n    CLOSE_WEIGHT: '^',\n    CONTINUATION: '~',\n  };\n\n  Object.assign(Symbols, v2Compatible ? v2Symbols : v3Symbols);\n\n  const Escaped = {};\n  Object.entries(Symbols).forEach(([k, v]) => { Escaped[k] = escapeRegex(v) });\n\n  const ENTITY_PATTERN = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/i;\n  const PENDING_GATE_PATTERN = new RegExp(`${Escaped.PENDING_GATE}([0-9]{9,11})`)\n\n  Escaped.SPECIAL = Object.values(Escaped).join('').replace(/[<>@]/g, ''); // allow <> for html, @ for md-links\n\n  const DYN = createToken({ name: \"DYN\", pattern: new RegExp(Escaped.DYNAMIC) });\n  const STAT = createToken({ name: \"STAT\", pattern: new RegExp(Escaped.STATIC) });\n  const OC = createToken({ name: \"OC\", pattern: new RegExp(Escaped.OPEN_CHOICE + '\\\\s*') });\n  const CC = createToken({ name: \"CC\", pattern: new RegExp(`\\\\s*${Escaped.CLOSE_CHOICE}`) });\n  const OS = createToken({ name: \"OS\", pattern: new RegExp(`${Escaped.OPEN_SILENT}\\\\s*`) });\n  const CS = createToken({ name: \"CS\", pattern: new RegExp(`\\\\s*${Escaped.CLOSE_SILENT}`) });\n  const ELSE = createToken({ name: \"ELSE\", pattern: /\\s*\\|\\|\\s*/ });\n  const OR = createToken({ name: \"OR\", pattern: /\\s*\\|\\s*/ });\n  const EQ = createToken({ name: \"EQ\", pattern: /\\s*=\\s*/ });\n  const AMP = createToken({ name: \"AMP\", pattern: /&/ });\n\n  // Group placement allows for bare $ symbols here\n  const Symbol = createToken({ name: \"Symbol\", pattern: new RegExp(`(${Escaped.DYNAMIC}|${Escaped.STATIC}[A-Za-z_0-9])[A-Za-z_0-9]*(\\\\(\\\\))?`) });\n  const Transform = createToken({ name: \"Transform\", pattern: /\\.[A-Za-z_0-9][A-Za-z_0-9]*(\\(\\))?/ });\n  const Entity = createToken({ name: \"Entity\", pattern: ENTITY_PATTERN });\n  const Weight = createToken({ name: \"Weight\", pattern: new RegExp(`\\\\s*${Escaped.OPEN_WEIGHT}\\\\d+${Escaped.CLOSE_WEIGHT}\\\\s*`) }); // TODO: change for negative weights\n  const PendingGate = createToken({ name: \"PendingGate\", pattern: PENDING_GATE_PATTERN });\n  const Raw = createToken({ name: \"Raw\", pattern: new RegExp(`[^${Escaped.SPECIAL}]+`) });\n\n  // @ts-ignore\n  const Gate = createToken({ name: \"Gate\", line_breaks: true, pattern: bracketMatch });\n\n  const tokens = [Gate, Entity, Weight, ELSE, OC, CC, OR, EQ, Symbol, DYN, STAT, AMP, Transform, OS, CS, PendingGate, Raw];\n\n  return { tokens, Constants: { Symbols, Escaped } };\n}\n\nfunction bracketMatch(text, startOffset) {\n\n  if (!/^@/.test(text.substring(startOffset))) return null;\n\n  let endOffset = startOffset + 1;\n\n  let dbug = 0;\n  if (dbug) console.log('bracketMatch', text);\n  let charCode = text.charCodeAt(endOffset);\n\n  // spaces between the @ and the open brace \n  while (charCode === 32) {\n    endOffset++;\n    charCode = text.charCodeAt(endOffset);\n  }\n  if (charCode !== 123) { // 123 = '{'\n    if (dbug) console.log(`  \"${text.substring(startOffset, endOffset)}\" -> null1`);\n    return null;\n  }\n  endOffset++;\n  charCode = text.charCodeAt(endOffset);\n  let depth = 1;\n  while (depth > 0) {\n    if (charCode === 123) depth++; // 123 = '{'\n    else if (charCode === 125) depth--; // 123 = '}'\n    if (dbug) console.log('  depth', depth, text.substring(startOffset, endOffset));\n    endOffset++;\n    charCode = text.charCodeAt(endOffset);\n  }\n\n  // No match, must return null xsto conform with the RegExp.prototype.exec signature\n  if (endOffset === startOffset) {\n    if (dbug) console.log(`\"${text.substring(startOffset, endOffset)}\" -> null3`);\n    return null;\n  } else {\n    let matchedString = text.substring(startOffset, endOffset);\n    // according to the RegExp.prototype.exec API the first item in the returned array must be the whole matched string.\n    if (dbug) console.log('  returned -> ', [matchedString]);\n    return [matchedString];\n  }\n}\n\nfunction escapeRegex(s) {\n  return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\nconst TextTypes = ['Raw', 'STAT', 'AMP'];\n\nexport { getTokens, TextTypes };","\nimport { RiScript } from './riscript.js'\nimport { RiScriptVisitor } from './visitor.js' // 12/13/2023\n\n/**\n * A probabilistic context-free grammar for text-generation, supporting all RiScript\n *  features, including transforms, gates, choices, sequences and assignments.\n * @class RiGrammar\n * @memberof module:riscript\n */\nclass RiGrammar {\n\n  static RiScript = null; // assigned in riscript.js\n\n  /**\n   * Creates an instance of RiGrammar.\n   * @param {Object<string, string>|string} [rules] - an object (or JSON string) containing the rules\n   * @param {Object<string, any>} [context] - the context (or world-state)\n   * @param {Object<string, any>} [options] - options for the grammar\n   */\n  constructor(rules = {}, context = {}, options = {}) {\n\n    /** @type {Object<string, string>} */ this.rules = {};\n    /** @type {Object<string, any>} */ this.context = context;\n    /** @type {RiScript} */ this.scripting = options.RiTa?.riscript ?? new RiScript(options);\n\n    if (typeof rules === 'string') {\n      rules = parseJSON(rules);\n    }\n\n    if (typeof rules !== 'object') {\n      throw Error('RiGrammar: expecting object, found ' + typeof rules);\n    }\n\n    this.setRules(rules);\n  }\n\n  /**\n   * Creates a new RiGrammar from the `rules`, `context` and `options`, then calls `expand()` on it.\n   * @param {string} rules - an object containing the rules\n   * @param {object} [context] - the context (or world-state) for the expansion\n   * @param {object} [options] - options for the expansion\n   * @param {string} [options.start='$start'] - the rule to start from\n   * @param {boolean} [options.trace=false] - whether to trace the evaluation to the console\n   * @param {boolean} [options.onepass=false] - whether to only do one evaluation pass \n   * @param {boolean} [options.silent=false] - whether to suppress console warnings\n   * @returns {string} - the expanded text\n   */\n  static expand(rules, context, options) {\n    return new RiGrammar(rules, context).expand(options);\n  }\n\n  /**\n   * Adds a transform to the Grammar instance\n   * @param {string} name - the name of the transform\n   * @param {Function} def - a function that takes a string and returns a string\n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  addTransform(name, def) {\n    this.scripting.addTransform(name, def);\n    return this;\n  }\n\n  /**\n   * Removes a transform from the Grammar instance\n   * @param {string} name \n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  removeTransform(name) {\n    this.scripting.removeTransform(name);\n    return this;\n  }\n\n  /**\n   * Returns the names of all current transforms\n   * @returns {string[]} the names of the transforms\n   */\n  getTransforms() {\n    return this.scripting.getTransforms();\n  }\n\n  /**\n   * Tests whether two grammars are equal and returns a boolean\n   * @param {RiGrammar} rg - the grammar to compare to \n   * @returns {boolean} - whether the grammars are equal\n   */\n  equals(rg) {\n    return rg.toJSON() === this.toJSON();\n  }\n\n  /**\n   * Expands a grammar from the supplied rule. If no rule is provided the `$start` and `<start>`\n   *  symbols will be checked respectively. If a context is needed, it should be passed when the\n   *  grammar is created.\n   * @param {object} [options] - options for the expansion\n   * @param {string} [options.start='$start'] - the rule to start from\n   * @param {boolean} [options.trace=false] - whether to trace the evaluation to the console\n   * @param {boolean} [options.onepass=false] - whether to only do one evaluation pass \n   * @param {boolean} [options.silent=false] - whether to suppress console warnings\n   * @returns {string} - the expanded text\n   */\n  expand(options = {}) {\n    if ('context' in options) {\n      throw Error('pass context to RiScript.grammar() or new RiGrammar() instead');\n    }\n\n    let visitor = new RiScriptVisitor(this.scripting);\n    visitor.context = this.context || {};\n\n    let clonedOpts = { ...options, visitor, input: this._toScript(options) };\n\n    return this.scripting._evaluate(clonedOpts);\n  }\n\n  /**\n   * Validates a rule and adds a new rule to the grammar\n   * @param {string} name - the name of the rule\n   * @param {string} def - the definition of the rule\n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  addRule(name, def) {\n    this._validateRule(name, def);\n    this.rules[name] = def;\n    return this;\n  }\n\n  /**\n   * Sets the rules for the grammar, removing any previous rules\n   * @param {object|string} rules - an object or JSON string holding the rules for the grammar \n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  setRules(rules) {\n    if (typeof rules === 'undefined') throw Error('undefined rules');\n    this.rules = {};\n    let incoming = typeof rules === 'string' ? parseJSON(rules) : rules;\n    Object.entries(incoming).forEach((e) => this.addRule(...e));\n    return this;\n  }\n\n  /**\n   * Removes a rule from the grammar\n   * @param {string} name - the name of the rule to remove\n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  removeRule(name) {\n    if (name in this.rules) {\n      delete this.rules[name];\n    }\n    return this;\n  }\n\n  /**\n   * Returns a JSON representation of the grammar rules, accepting options from `JSON.stringify()`\n   * @param {any} [replacer] - a replacer function or array\n   * @param {string | number} [space] - the number of spaces to indent\n   * @returns {string} - the JSON representation of the grammar\n   */\n  toJSON(replacer, space) {\n    return JSON.stringify(this.rules, replacer, space);\n  }\n\n  /** \n   * Returns a string representation of the grammar, accecpting the same options as `JSON.stringify()`\n   * @param {object} [options] - options for the string representation\n   * @param {any} [options.replacer] - a replacer function or array\n   * @param {string | number} [options.space] - the number of spaces to indent\n   * @param {string} [options.linebreak] - the linebreak character to use\n   */\n  toString(options = {}) {\n    let replacer = options.replacer || 0;\n    let space = options.space || 2;\n    let lb = options?.linebreak;\n    let res = this.toJSON(replacer, space);\n    if (lb) res = res.replace(/\\n/g, lb);\n    return res;\n  }\n\n  /**\n   * Creates a new RiGrammar from the supplied JSON string\n   * @param {string} json - a JSON string representing the grammar\n   * @param {object} [context] - optional context for the grammar\n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  static fromJSON(json, context) {\n    return new RiGrammar(JSON.parse(json), context);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Converts grammar to inline rules; rules are dynamic, unless otherwise specified with leading #\n   * @private\n   */\n  _toScript(opts) {\n\n    let script = '', start = opts.start || 'start';\n\n    let { Symbols } = this.scripting;\n\n    if (start.startsWith(Symbols.DYNAMIC)) {\n      start = start.substring(Symbols.DYNAMIC.length);\n    }\n\n    if (start.startsWith(Symbols.STATIC)) {\n      start = start.substring(Symbols.STATIC.length);\n    }\n\n    if (!(start in this.rules || Symbols.STATIC + start in this.rules)) {\n      throw Error('Rule: \"' + start + '\" not found in grammar');\n    }\n\n    Object.entries(this.rules).forEach(([name, rule], i) => {\n      while (name.startsWith(Symbols.DYNAMIC)) {\n        name = name.substring(1);\n      }\n      if (!name.startsWith(Symbols.STATIC)) {\n        name = Symbols.DYNAMIC + name;\n      }\n      // console.log(i,name);\n      if (!this.scripting.regex.ChoiceWrap.test(rule)) {\n        // let orig = rule;\n        rule = Symbols.OPEN_CHOICE + rule + Symbols.CLOSE_CHOICE;\n        // console.log('WRAPPING: ' + orig + '->' + rule);\n      }\n      script += `${name}=${rule}\\n`;\n    });\n\n    if (opts.trace) console.log('Grammar:\\n' + script.replace(/^\\$/gm, '  $'));\n\n    script += `${Symbols.DYNAMIC}${start}`;\n\n    return script;\n  }\n\n  /**\n   * Validates a grammar rule\n   * @private\n   */\n  _validateRule(name, def) {\n    if (typeof name !== 'string' || name.length === 0) {\n      throw Error('expected [string] name');\n    }\n\n    if (typeof def === 'undefined') {\n      throw Error('undefined rule def: ' + name);\n    }\n    let { Symbols } = this.scripting;\n\n    if (name.startsWith(Symbols.DYNAMIC)) {\n      name = name.substring(Symbols.DYNAMIC.length);\n      throw Error('Grammar rules are dynamic by default;' +\n        \" if you need a static rule, use '\" + Symbols.STATIC +\n        name + \"', otherwise just use '\" + name + \"'.\");\n    }\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nfunction parseJSON(json) {\n  if (typeof json === 'string') {\n    try {\n      return JSON.parse(json);\n    } catch (e) {\n      throw Error('RiGrammar appears to be invalid JSON,' +\n        ' please check it at http://jsonlint.com/\\n' + json);\n    }\n  }\n}\n\nexport { RiGrammar };\n"],"names":["result","Symbol","escapeText","text"],"mappings":"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","ignoreList":[0,1,2,3,4,5]}},
    {"offset": {"line": 3336, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3342, "column": 0}, "map": {"version":3,"sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40ungap/structured-clone/esm/types.js"],"sourcesContent":["export const VOID       = -1;\nexport const PRIMITIVE  = 0;\nexport const ARRAY      = 1;\nexport const OBJECT     = 2;\nexport const DATE       = 3;\nexport const REGEXP     = 4;\nexport const MAP        = 5;\nexport const SET        = 6;\nexport const ERROR      = 7;\nexport const BIGINT     = 8;\n// export const SYMBOL = 9;\n"],"names":[],"mappings":";;;;;;;;;;;;AAAO,MAAM,OAAa,CAAC;AACpB,MAAM,YAAa;AACnB,MAAM,QAAa;AACnB,MAAM,SAAa;AACnB,MAAM,OAAa;AACnB,MAAM,SAAa;AACnB,MAAM,MAAa;AACnB,MAAM,MAAa;AACnB,MAAM,QAAa;AACnB,MAAM,SAAa,GAC1B,2BAA2B","ignoreList":[0]}},
    {"offset": {"line": 3364, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3370, "column": 0}, "map": {"version":3,"sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40ungap/structured-clone/esm/deserialize.js"],"sourcesContent":["import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst env = typeof self === 'object' ? self : globalThis;\n\nconst deserializer = ($, _) => {\n  const as = (out, index) => {\n    $.set(index, out);\n    return out;\n  };\n\n  const unpair = index => {\n    if ($.has(index))\n      return $.get(index);\n\n    const [type, value] = _[index];\n    switch (type) {\n      case PRIMITIVE:\n      case VOID:\n        return as(value, index);\n      case ARRAY: {\n        const arr = as([], index);\n        for (const index of value)\n          arr.push(unpair(index));\n        return arr;\n      }\n      case OBJECT: {\n        const object = as({}, index);\n        for (const [key, index] of value)\n          object[unpair(key)] = unpair(index);\n        return object;\n      }\n      case DATE:\n        return as(new Date(value), index);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as(new RegExp(source, flags), index);\n      }\n      case MAP: {\n        const map = as(new Map, index);\n        for (const [key, index] of value)\n          map.set(unpair(key), unpair(index));\n        return map;\n      }\n      case SET: {\n        const set = as(new Set, index);\n        for (const index of value)\n          set.add(unpair(index));\n        return set;\n      }\n      case ERROR: {\n        const {name, message} = value;\n        return as(new env[name](message), index);\n      }\n      case BIGINT:\n        return as(BigInt(value), index);\n      case 'BigInt':\n        return as(Object(BigInt(value)), index);\n      case 'ArrayBuffer':\n        return as(new Uint8Array(value).buffer, value);\n      case 'DataView': {\n        const { buffer } = new Uint8Array(value);\n        return as(new DataView(buffer), value);\n      }\n    }\n    return as(new env[type](value), index);\n  };\n\n  return unpair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns a deserialized value from a serialized array of Records.\n * @param {Record[]} serialized a previously serialized value.\n * @returns {any}\n */\nexport const deserialize = serialized => deserializer(new Map, serialized)(0);\n"],"names":[],"mappings":";;;AAAA;;AAOA,MAAM,MAAM,OAAO,SAAS,WAAW,OAAO;AAE9C,MAAM,eAAe,CAAC,GAAG;IACvB,MAAM,KAAK,CAAC,KAAK;QACf,EAAE,GAAG,CAAC,OAAO;QACb,OAAO;IACT;IAEA,MAAM,SAAS,CAAA;QACb,IAAI,EAAE,GAAG,CAAC,QACR,OAAO,EAAE,GAAG,CAAC;QAEf,MAAM,CAAC,MAAM,MAAM,GAAG,CAAC,CAAC,MAAM;QAC9B,OAAQ;YACN,KAAK,iKAAA,CAAA,YAAS;YACd,KAAK,iKAAA,CAAA,OAAI;gBACP,OAAO,GAAG,OAAO;YACnB,KAAK,iKAAA,CAAA,QAAK;gBAAE;oBACV,MAAM,MAAM,GAAG,EAAE,EAAE;oBACnB,KAAK,MAAM,SAAS,MAClB,IAAI,IAAI,CAAC,OAAO;oBAClB,OAAO;gBACT;YACA,KAAK,iKAAA,CAAA,SAAM;gBAAE;oBACX,MAAM,SAAS,GAAG,CAAC,GAAG;oBACtB,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,MACzB,MAAM,CAAC,OAAO,KAAK,GAAG,OAAO;oBAC/B,OAAO;gBACT;YACA,KAAK,iKAAA,CAAA,OAAI;gBACP,OAAO,GAAG,IAAI,KAAK,QAAQ;YAC7B,KAAK,iKAAA,CAAA,SAAM;gBAAE;oBACX,MAAM,EAAC,MAAM,EAAE,KAAK,EAAC,GAAG;oBACxB,OAAO,GAAG,IAAI,OAAO,QAAQ,QAAQ;gBACvC;YACA,KAAK,iKAAA,CAAA,MAAG;gBAAE;oBACR,MAAM,MAAM,GAAG,IAAI,KAAK;oBACxB,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,MACzB,IAAI,GAAG,CAAC,OAAO,MAAM,OAAO;oBAC9B,OAAO;gBACT;YACA,KAAK,iKAAA,CAAA,MAAG;gBAAE;oBACR,MAAM,MAAM,GAAG,IAAI,KAAK;oBACxB,KAAK,MAAM,SAAS,MAClB,IAAI,GAAG,CAAC,OAAO;oBACjB,OAAO;gBACT;YACA,KAAK,iKAAA,CAAA,QAAK;gBAAE;oBACV,MAAM,EAAC,IAAI,EAAE,OAAO,EAAC,GAAG;oBACxB,OAAO,GAAG,IAAI,GAAG,CAAC,KAAK,CAAC,UAAU;gBACpC;YACA,KAAK,iKAAA,CAAA,SAAM;gBACT,OAAO,GAAG,OAAO,QAAQ;YAC3B,KAAK;gBACH,OAAO,GAAG,OAAO,OAAO,SAAS;YACnC,KAAK;gBACH,OAAO,GAAG,IAAI,WAAW,OAAO,MAAM,EAAE;YAC1C,KAAK;gBAAY;oBACf,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,WAAW;oBAClC,OAAO,GAAG,IAAI,SAAS,SAAS;gBAClC;QACF;QACA,OAAO,GAAG,IAAI,GAAG,CAAC,KAAK,CAAC,QAAQ;IAClC;IAEA,OAAO;AACT;AAWO,MAAM,cAAc,CAAA,aAAc,aAAa,IAAI,KAAK,YAAY","ignoreList":[0]}},
    {"offset": {"line": 3441, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3447, "column": 0}, "map": {"version":3,"sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40ungap/structured-clone/esm/serialize.js"],"sourcesContent":["import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst EMPTY = '';\n\nconst {toString} = {};\nconst {keys} = Object;\n\nconst typeOf = value => {\n  const type = typeof value;\n  if (type !== 'object' || !value)\n    return [PRIMITIVE, type];\n\n  const asString = toString.call(value).slice(8, -1);\n  switch (asString) {\n    case 'Array':\n      return [ARRAY, EMPTY];\n    case 'Object':\n      return [OBJECT, EMPTY];\n    case 'Date':\n      return [DATE, EMPTY];\n    case 'RegExp':\n      return [REGEXP, EMPTY];\n    case 'Map':\n      return [MAP, EMPTY];\n    case 'Set':\n      return [SET, EMPTY];\n    case 'DataView':\n      return [ARRAY, asString];\n  }\n\n  if (asString.includes('Array'))\n    return [ARRAY, asString];\n\n  if (asString.includes('Error'))\n    return [ERROR, asString];\n\n  return [OBJECT, asString];\n};\n\nconst shouldSkip = ([TYPE, type]) => (\n  TYPE === PRIMITIVE &&\n  (type === 'function' || type === 'symbol')\n);\n\nconst serializer = (strict, json, $, _) => {\n\n  const as = (out, value) => {\n    const index = _.push(out) - 1;\n    $.set(value, index);\n    return index;\n  };\n\n  const pair = value => {\n    if ($.has(value))\n      return $.get(value);\n\n    let [TYPE, type] = typeOf(value);\n    switch (TYPE) {\n      case PRIMITIVE: {\n        let entry = value;\n        switch (type) {\n          case 'bigint':\n            TYPE = BIGINT;\n            entry = value.toString();\n            break;\n          case 'function':\n          case 'symbol':\n            if (strict)\n              throw new TypeError('unable to serialize ' + type);\n            entry = null;\n            break;\n          case 'undefined':\n            return as([VOID], value);\n        }\n        return as([TYPE, entry], value);\n      }\n      case ARRAY: {\n        if (type) {\n          let spread = value;\n          if (type === 'DataView') {\n            spread = new Uint8Array(value.buffer);\n          }\n          else if (type === 'ArrayBuffer') {\n            spread = new Uint8Array(value);\n          }\n          return as([type, [...spread]], value);\n        }\n\n        const arr = [];\n        const index = as([TYPE, arr], value);\n        for (const entry of value)\n          arr.push(pair(entry));\n        return index;\n      }\n      case OBJECT: {\n        if (type) {\n          switch (type) {\n            case 'BigInt':\n              return as([type, value.toString()], value);\n            case 'Boolean':\n            case 'Number':\n            case 'String':\n              return as([type, value.valueOf()], value);\n          }\n        }\n\n        if (json && ('toJSON' in value))\n          return pair(value.toJSON());\n\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const key of keys(value)) {\n          if (strict || !shouldSkip(typeOf(value[key])))\n            entries.push([pair(key), pair(value[key])]);\n        }\n        return index;\n      }\n      case DATE:\n        return as([TYPE, value.toISOString()], value);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as([TYPE, {source, flags}], value);\n      }\n      case MAP: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const [key, entry] of value) {\n          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))\n            entries.push([pair(key), pair(entry)]);\n        }\n        return index;\n      }\n      case SET: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const entry of value) {\n          if (strict || !shouldSkip(typeOf(entry)))\n            entries.push(pair(entry));\n        }\n        return index;\n      }\n    }\n\n    const {message} = value;\n    return as([TYPE, {name: type, message}], value);\n  };\n\n  return pair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} value a serializable value.\n * @param {{json?: boolean, lossy?: boolean}?} options an object with a `lossy` or `json` property that,\n *  if `true`, will not throw errors on incompatible types, and behave more\n *  like JSON stringify would behave. Symbol and Function will be discarded.\n * @returns {Record[]}\n */\n export const serialize = (value, {json, lossy} = {}) => {\n  const _ = [];\n  return serializer(!(json || lossy), !!json, new Map, _)(value), _;\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3661, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3667, "column": 0}, "map": {"version":3,"sources":["file:///Users/karlie/Documents/GitHub/lecsicon_newUI/node_modules/%40ungap/structured-clone/esm/json.js"],"sourcesContent":["/*! (c) Andrea Giammarchi - ISC */\n\nimport {deserialize} from './deserialize.js';\nimport {serialize} from './serialize.js';\n\nconst {parse: $parse, stringify: $stringify} = JSON;\nconst options = {json: true, lossy: true};\n\n/**\n * Revive a previously stringified structured clone.\n * @param {string} str previously stringified data as string.\n * @returns {any} whatever was previously stringified as clone.\n */\nexport const parse = str => deserialize($parse(str));\n\n/**\n * Represent a structured clone value as string.\n * @param {any} any some clone-able value to stringify.\n * @returns {string} the value stringified.\n */\nexport const stringify = any => $stringify(serialize(any, options));\n"],"names":[],"mappings":"AAAA,gCAAgC;;;;AAEhC;AACA;;;AAEA,MAAM,EAAC,OAAO,MAAM,EAAE,WAAW,UAAU,EAAC,GAAG;AAC/C,MAAM,UAAU;IAAC,MAAM;IAAM,OAAO;AAAI;AAOjC,MAAM,QAAQ,CAAA,MAAO,CAAA,GAAA,uKAAA,CAAA,cAAW,AAAD,EAAE,OAAO;AAOxC,MAAM,YAAY,CAAA,MAAO,WAAW,CAAA,GAAA,qKAAA,CAAA,YAAS,AAAD,EAAE,KAAK","ignoreList":[0]}},
    {"offset": {"line": 3682, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}